<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!--
MIT License

Copyright (c) 2020 Viresh Ratnakar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

The latest code and documentation for Exet can be found at:
https://github.com/viresh-ratnakar/exet

Current version: v0.13 September 26, 2020
-->

<link rel="stylesheet" type="text/css" href="exolve-m.css?v0.91"/>
<script src="exolve-m.js?v0.91"></script>
<script src="lufz-en-lexicon.js"></script>

<style>
[contenteditable="true"]:active,
[contenteditable="true"]:focus{
  border:none;
  outline:none;
}
.xet-frame {
  width: 940px;
  margin: 0 8px;
  box-sizing: border-box;
  font-family: monospace;
  font-size: 14px;
}
.xet-controls-col {
  padding: 4px;
}
.xet-frame hr {
  margin-left: 0;
  margin-right: 0;
}
.xet-tab {
  height: 50px;
  border: 4px solid #ddd;
  border-bottom: 0;
  background-color: #ddd;
  border-radius: 10px 10px 0 0;
  overflow: auto;
}
.xet-tab button {
  font-size: 14px;
  width: 105px;
  height: 100%;
  background-color: inherit;
  float: left;
  outline: none;
  cursor: pointer;
  padding: 2px 4px;
  transition: 0.3s;
  font-weight: bold;
  border-radius: 10px 10px 0 0;
  border: 1px solid silver;
}
.xet-tab button:hover {
  background-color: #f0f0f0;
  border-bottom: 0;
  cursor: pointer;
}
.xet-tab button.active {
  background-color: white;
  border-bottom: 0;
}
.xet-tabcontent {
  display: none;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-top: none;
}
.xet-td {
  vertical-align: top;
}
.xet-iframe {
  width: 910px;
  border: 0;
  overflow: auto;
}
.xet-panel {
  width: 910px;
  border: 0;
  overflow: auto;
}
.xet-section {
  border: 0;
}
.xet-high-tall-box {
  height: 450px;
}
.xet-mid-tall-box {
  height: 320px;
}
.xet-low-tall-box {
  height: 250px;
}
.xet-anno {
  font-family: monospace;
  font-size: 14px;
  color: darkgreen;
}
.xlv-curr-clue {
  font-family: monospace;
  font-weight: normal;
  font-size: 14px;
  padding: 2px 2px 4px 2px;
}
.xet-red {
  color: red;
}
.xet-blue {
  color: blue;
  text-decoration: none;
}
.xet-small {
  font-family: monospace;
  font-size: 10px;
}
.xet-bold {
  font-weight: bold;
}
.xet-controls-row {
  display: flex;
  flex-flow: row wrap;
  justify-content: left;
}
.xet-controls-col {
  display: flex;
  flex-flow: column wrap;
  align-items: flex-start;
}
.xet-choices-box {  
  overflow-y: auto;
  overflow-x: hidden;
  margin: 4px 0;
  border: 1px solid gray;
  border-collapse: collapse;
  box-sizing: border-box;
}
#xet-light-choices-box {  
  width: 30ch;
  height: 400px;
}
#xet-light-choices {  
  font-size: 16px;
}
.xet-choices {  
  table-layout: auto;
  margin: 0;
  padding: 0;
  width: 100%;
  color: #333;
  border: 1px solid gray;
  border-collapse: collapse;
  border-spacing: 0; 
  font-family: monospace;
  font-size: 12px;
}
.xet-choices td, .xet-choices th {
  border: 0;
  border-right: 1px solid gray;
  border-left: 1px solid gray;
  padding: 8px;
}
.xet-choices th {  
  background: #DFDFDF;
  font-weight: bold;
}
.xet-choices td {  
  background: #FAFAFA;
  text-align: left;
  cursor: pointer;
}
.xet-choices tr:nth-child(even) td { background: #F1F1F1; }   
.xet-choices tr:nth-child(odd) td { background: #FEFEFE; }  
.xet-choices:not(.xet-picked) tr:hover td {
  background: lightgreen;
}  
.xet-menu {
  position: relative;
  width:100%;
}
.xet-menu ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
.xet-menu li {
  float: left;
}
.xet-metadata {
  text-align: center;
  padding: 8px 12px;
  width: 500px;
}
.xet-edit {
  color: darkgreen;
  cursor: auto;
}
.xet-dropbtn {
  display: inline-block;
  text-align: center;
  padding: 8px 12px;
  margin: 0;
  font-size: 14px;
  font-weight: bold;
  border-radius: 10px 10px 0 0;
  border: 1px solid transparent;
}
.xet-dropdown:hover .xet-dropbtn {
  background-color: #ddd;
  cursor: pointer;
  border: 1px solid gray;
}
.xet-menu li.xet-dropdown {
  display: inline-block;
}
.xet-dropdown-content,
.xet-dropdown-submenu {
  display: none;
  position: absolute;
  background-color: #f9f9f9;
  min-width: 275px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
  margin: 0;
  border: 1px solid gray;
}
.xet-dropdown-submenu {
  top: 0;
  left: 100%;
}
.xet-dropdown-item,
.xet-dropdown-subitem {
  margin: 0;
  padding: 15px;
  display: block;
  text-align: left;
  position: relative;
}
.xet-dropdown-content .xet-dropdown-item:nth-child(odd) { background: #F1F1F1; }   
.xet-dropdown-content .xet-dropdown-item:nth-child(even) { background: #FEFEFE; }  
.xet-dropdown-content .xet-dropdown-item:hover {
  background-color: lightgreen;
  cursor: pointer;
}
.xet-dropdown-submenu .xet-dropdown-subitem:nth-child(odd) { background: #F1F1F1; }   
.xet-dropdown-submenu .xet-dropdown-subitem:nth-child(even) { background: #FEFEFE; }  
.xet-dropdown-submenu .xet-dropdown-subitem:hover {
  background-color: #a1ffa1;
  cursor: pointer;
}
.xet-dropdown-item:hover .xet-dropdown-submenu {
  display: block;
}
.xet-frame .xlv-clues {
  font-size: 16px;
  font-family: serif;
  font-weight: 400;
  line-height: normal;
  box-sizing: border-box;
}
.xlv-frame .xlv-clues td:not(:first-child) {
  padding: 4px 0 0 0;
}
.xet-frame .xlv-clues,
.xet-frame .xlv-clues-box {
  width: 634px;
}
.xet-clues {
  width: 640px;
}
.xet-rev-chooser {
  position: absolute;
  z-index: 1;
  background-color: white;
  border: 1px solid gray;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  font-size: 12px;
}
.xet-chosen {
  font-weight: bold;
  color: darkgreen;
}
.xet-editable {
  border: 1px solid lightgreen;
  padding: 4px;
  line-height: 1.8;
}
.xet-action {
  color: dodgerblue;
  font-weight: normal;
  font-family: serif;
  font-size: 16px;
  font-style: italic;
  margin: 4px 0;
}
#xet-scratch-pad {
  margin: 0 6px 6px;
}
.xet-icon {
  padding: 0;
  height: 25px;
  width: 25px;
}
.xet-companag {
  padding: 0 0 8px 0;
  overflow: auto;
}
.xet-companag-text {
  color: blue;
  font-family: monospace;
  font-size: 14px;
}
.xet-table-midline td:nth-child(2) {
  border-left: 1px solid gray;
  padding-left: 4px;
}
.xet-table-midline td {
  padding-top: 4px;
}
.xet-preview {
  height: 300px;
  width:800px;
  overflow:auto;
}
.xet-full-width {
  width: 100%;
}
#xet-charade-choices td {
  padding: 3px 0;
}
.xet-sweeping-box {
  display: inline-block;
  position: absolute;
  height: 31px;
  width: 31px;
  right: 0;
  bottom: -22px;
}
@keyframes xet-sweeping {
  from {width: 0; height: 0; border-radius: 0; left: 15.5px; top: 15.5px; background: red;}
  to {width: 10px; height: 10px; border-radius: 5px; left: 10.5px; top: 10.5px; background: red;}
}
.xet-sweeping,
.xet-sweeping-animated {
  position: absolute;
}
.xet-sweeping {
  left: 15.5px;
  top: 15.5px;
  width: 0;
  height: 0;
  border-radius: 0;
}
.xet-sweeping-animated {
  animation-name: xet-sweeping;
  animation-duration: 2s;
  animation-direction: alternate;
  animation-iteration-count: infinite;
}
</style>

<title>Exet: Create a crossword</title>

</head>
<body>

<div id="xet-xlv-frame">
</div>

<script>

function ExetModals() {
  this.modal = null;
  document.addEventListener('click', this.handleClick.bind(this));
};

ExetModals.prototype.handleClick = function(e) {
  if (!this.modal) {
    return
  }
  if (!this.modal.contains(e.target)) {
    this.hide()
  }
}

// If caller calls this in response to a click event e, then caller should also
// call e.stopPropagation().
ExetModals.prototype.showModal = function(elt) {
  this.hide()
  if (!elt) {
    return
  }
  this.modal = elt;
  this.modal.style.display = 'block'
}

ExetModals.prototype.hide = function() {
  if (!this.modal) {
    return
  }
  this.modal.style.display = 'none'
  this.modal = null;
}

function ExetRevManager() {
  this.REV_LOADED_FROM_FILE = 1
  this.REV_CREATED_BLANK = 2
  this.REV_CREATED_AUTOBLOCK = 3
  this.REV_JUMPED_TO_REV = 10
  this.REV_GRID_CHANGE = 20
  this.REV_GRIDFILL_CHANGE = 30
  this.REV_ENUM_CHANGE = 40
  this.REV_CLUE_CHANGE = 50
  this.REV_METADATA_CHANGE = 60

  this.revMsgs = {}
  this.revMsgs[this.REV_LOADED_FROM_FILE] = "Loaded from a file"
  this.revMsgs[this.REV_CREATED_BLANK] = "Created a blank grid"
  this.revMsgs[this.REV_CREATED_AUTOBLOCK] = "Created a blank grid with automagic blocks"
  this.revMsgs[this.REV_JUMPED_TO_REV] = "Jumped to a previous revision"
  this.revMsgs[this.REV_GRID_CHANGE] = "Grid change"
  this.revMsgs[this.REV_GRIDFILL_CHANGE] = "Grid-fill change"
  this.revMsgs[this.REV_ENUM_CHANGE] = "Enum change"
  this.revMsgs[this.REV_CLUE_CHANGE] = "Clue or anno change"
  this.revMsgs[this.REV_METADATA_CHANGE] = "Metadata change"

  // State for throttled revision-saving
  this.throttleRevTimer = null;
  this.saveLagMS = 5000
  this.throttlingLastRev = 0;

  // Special localStorage key for storing preferences and state
  this.SPECIAL_KEY = '42-exet-42'
  this.spaceUsedAtStart = 0
  for (let idx = 0; idx < window.localStorage.length; idx++) {
    let id = window.localStorage.key(idx)
    this.spaceUsedAtStart += window.localStorage.getItem(id).length
  }
  this.spaceUsed = this.spaceUsedAtStart

  let k500 = '1234567812345678'
  while (k500.length < 500000) {
    k500 = k500 + k500
  }
  let tempKey = '42-exet-cap-42-'
  this.spaceLeftAtStart = 0
  for (let i = 0; i < 20; i++) {
    // Only count up to 10 MB
    try {
      window.localStorage.setItem(tempKey + i, k500)
      this.spaceLeftAtStart += k500.length
    } catch (err) {
      break
    }
  }
  for (let i = 0; i < 20; i++) {
    window.localStorage.removeItem(tempKey + i)
  }

  // Id for previews
  this.previewId = `exet-preview-${Math.random().toString(36).substring(2, 8)}`
};

ExetRevManager.prototype.inMB = function(num) {
  return (num / 1000000).toFixed(2)
}

ExetRevManager.prototype.choosePuzRev = function(manageStorage=false, puz, elt, callback) {
  let choices = []
  if (puz) {
    let stored = window.localStorage.getItem(puz.id)
    let spaceUsed = stored.length
    choices = [{id: puz.id, title: puz.title, space: spaceUsed}]
  } else {
    this.spaceUsed = 0
    for (let idx = 0; idx < window.localStorage.length; idx++) {
      let id = window.localStorage.key(idx)
      let stored = window.localStorage.getItem(id)
      let spaceUsed = stored.length
      this.spaceUsed += spaceUsed
      if (id == this.SPECIAL_KEY) {
        continue
      }
      try {
        stored = JSON.parse(stored)
      } catch (err) {
        continue
      }
      if (!stored || !stored["id"] || !stored["revs"] || !stored["maxRevNum"]) {
        continue
      }
      let title = ''
      if (stored.revs.length > 0) {
        title = stored.revs[stored.revs.length - 1].title
      }
      choices.push({id: stored.id, title: title, space: spaceUsed})
    }
  }
  let html = `
  <table>
    <tr>
      <td><i>Select puzzle ID/Title</i></td>
      <td>
        <i>Select revision</i>
      </td>
    </tr>
    <tr>
      <td>
        <div class="xet-choices-box" id="xet-choose-id">
          <table class="xet-choices" id="xet-id-choices">`
  for (let i = 0; i < choices.length; i++) {
    html = html + `
      <tr id="xet-id-choice-${i}"><td>${choices[i].id}</td><td>${choices[i].title}</td><td>${this.inMB(choices[i].space)} MB</td></tr>`
  }
  html = html + `
          </table>
        </div>
      </td>
      <td>
        <div class="xet-choices-box" id="xet-choose-rev">
          <table class="xet-choices" id="xet-rev-choices">
          </table>
        </div>
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div>
          <span>Space used: ${this.inMB(this.spaceUsed)} MB</span>
          <span>Space available: <span class="xet-red">${this.inMB(this.spaceUsedAtStart + this.spaceLeftAtStart - this.spaceUsed)}</span> MB</span>
          <button id="xset-puz-rev-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete rev</button>
          <button id="xset-puz-prior-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete older revs!</button>
          <button id="xset-puz-deleter"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Delete!</button>
          <button id="xset-puz-rev-selector"
            style="float:right;margin: 0 16px; display: none"
            class="xlv-button">Open</button>
        </div>
        <div id="xet-preview" class="xet-preview">
        </div>
      </td>
    </tr>
  </table>
  `
  elt.innerHTML = html
  this.idChoicesBox = document.getElementById('xet-choose-id')
  this.idChoicesBox.style.width = '270px'
  this.idChoicesBox.style.height = '200px'
  this.idChoices = document.getElementById('xet-id-choices')
  this.revChoicesBox = document.getElementById('xet-choose-rev')
  this.revChoicesBox.style.width = '500px'
  this.revChoicesBox.style.height = '200px'
  this.revChoices = document.getElementById('xet-rev-choices')
  this.preview = document.getElementById('xet-preview')
  this.idChoice = ''
  this.revChoice = -1
  this.puzDeleter = document.getElementById('xset-puz-deleter')
  this.puzPriorDeleter = document.getElementById('xset-puz-prior-deleter')
  this.puzRevDeleter = document.getElementById('xset-puz-rev-deleter')
  this.puzRevSelector = document.getElementById('xset-puz-rev-selector')
  this.manageStorage = manageStorage
  if (manageStorage) {
    this.puzDeleter.style.display = ''
    this.puzPriorDeleter.style.display = ''
    this.puzRevDeleter.style.display = ''
    this.puzDeleter.disabled = true
    this.puzPriorDeleter.disabled = true
    this.puzRevDeleter.disabled = true
    let deleter = (types, e) => {
      if (!confirm('Are you sure you want to delete ' + types + ' revision(s)?')) {
        return
      }
      this.idChoices.className = 'xet-choices'
      this.revChoices.className = 'xet-choices'
      if (types == 'all') {
        window.localStorage.removeItem(this.idChoice)
      } else {
        if (this.revChoice < 0 || !this.storedRevs ||
            this.storedRevs.revs.length == 0 ||
            this.revChoice >= this.storedRevs.revs.length) {
          console.log('Weird, did not find revChoice/storedRevs to delete from')
          return
        }
        let lastToDelete = this.revChoice
        if (types == 'prior') lastToDelete--
        let numToDelete = (types == 'prior' ? lastToDelete + 1 : 1)
        let newRevs = []
        if (lastToDelete - numToDelete >= 0) {
          newRevs = this.storedRevs.revs.slice(0, lastToDelete - numToDelete + 1)
        }
        this.storedRevs.revs = newRevs.concat(this.storedRevs.revs.slice(lastToDelete + 1))
        this.saveLocal(this.idChoice, JSON.stringify(this.storedRevs))
      }
      this.choosePuzRev(true, null, exet.revChooser, null)
      e.stopPropagation()
    }
    this.puzDeleter.addEventListener('click', deleter.bind(this, 'all'))
    this.puzPriorDeleter.addEventListener('click', deleter.bind(this, 'prior'))
    this.puzRevDeleter.addEventListener('click', deleter.bind(this, 'this'))
  } else {
    this.puzRevSelector.style.display = ''
    this.puzRevSelector.disabled = true
    this.puzRevSelector.addEventListener('click', e => {
      if (this.revChoice < 0 || !this.storedRevs ||
          this.storedRevs.revs.length == 0 ||
          this.revChoice >= this.storedRevs.revs.length) {
        console.log('Hmm: bad selection! Check ExetRevManager:')
        console.log(this)
        return
      }
      exetModals.hide()
      this.idSelectors = []
      this.revSelectors = []
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      callback(this.storedRevs.revs[this.revChoice])
    })
  }

  this.idSelectors = []
  this.revSelectors = []
  this.storedRevs = null
  if (puz) {
    this.idChoice = puz.id
    document.getElementById("xet-id-choice-0").className = 'xet-chosen'
    this.chooseRev()
    return
  }
  for (let i = 0; i < choices.length; i++) {
    let selector = document.getElementById(`xet-id-choice-${i}`)
    this.idSelectors.push(selector)
    let id = choices[i].id
    selector.addEventListener('click', e => {
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      this.puzDeleter.disabled = true
      this.puzPriorDeleter.disabled = true
      this.puzRevDeleter.disabled = true
      this.revChoices.innerHTML = ''
      this.revChoices.className = 'xet-choices'
      this.revChoice = -1
      this.revSelectors = []
      this.storedRevs = null
      this.puzRevSelector.disabled = true
      if (id == this.idChoice) {
        this.idChoice = null
        selector.className = ''
        this.idChoices.className = 'xet-choices'
      } else {
        for (let j = 0; j < choices.length; j++) {
          if (j != i) {
            this.idSelectors[j].className = ''
          }
        }
        this.idChoice = id
        this.puzDeleter.disabled = false
        selector.className = 'xet-chosen'
        this.idChoices.className = 'xet-choices xet-picked'
        this.chooseRev()
      }
    })
  }
};

ExetRevManager.prototype.chooseRev = function() {
  let stored = window.localStorage.getItem(this.idChoice)
  if (!stored) {
    return
  }
  this.storedRevs = JSON.parse(stored)
  let html = ''
  for (let idx = this.storedRevs.revs.length - 1; idx >= 0; idx--) {
    let rev = this.storedRevs.revs[idx]
    let revTime = new Date(rev.timestamp)
    html = html + `
      <tr id="xet-rev-choice-${idx}">
        <td>${rev.title}</td>
        <td>#${rev.revNum}</td>
        <td>${revTime.toLocaleString()}</td>
        <td>${exetRevManager.revMsgs[rev.revType]}</td>
        <td>${rev.details}</td>
      </tr>`
  }
  this.revChoices.innerHTML = html
  this.revSelectors = []
  this.revChoice = -1
  for (let i = 0; i < this.storedRevs.revs.length; i++) {
    let selector = document.getElementById(`xet-rev-choice-${i}`)
    this.revSelectors.push(selector)
    selector.addEventListener('click', e => {
      if (!this.storedRevs) {
        return
      }
      this.puzPriorDeleter.disabled = true
      this.puzRevDeleter.disabled = true
      this.puzRevSelector.disabled = true
      this.preview.innerHTML = ''
      delete exolvePuzzles[this.previewId]
      if (i == this.revChoice) {
        this.revChoice = -1
        selector.className = ''
        this.revChoices.className = 'xet-choices'
      } else {
        for (let j = 0; j < this.revSelectors.length; j++) {
          if (j != i) {
            this.revSelectors[j].className = ''
          }
        }
        this.revChoice = i
        selector.className = 'xet-chosen'
        this.revChoices.className = 'xet-choices xet-picked'
        let exolve = this.storedRevs.revs[i].exolve.replace(/exolve-id:[ ]*[a-zA-Z0-9-]*/,
            `exolve-id: ${this.previewId}`)
        let newPuz = new Exolve(exolve, "xet-preview", null, false, 0, 400)
        newPuz.revealAll(false)
        this.puzPriorDeleter.disabled = (i <= 0)
        this.puzRevDeleter.disabled = false
        this.puzRevSelector.disabled = false
      }
    })
  }
};

ExetRevManager.prototype.saveLocal = function(k, v) {
  try {
    window.localStorage.setItem(k, v)
  } catch (err) {
    alert('No available local storage left. Please use the "Manage storage" menu option to free up some space.')
    console.log('Could not save value of length ' + v.length + ' for key: ' + k)
  }
}

ExetRevManager.prototype.saveRev = function(revType, details="") {
  if (!exet || !exet.puz || !exet.puz.id) {
    console.log('Cannot save revision when there is no puzzle!')
    return
  }
  let stored = window.localStorage.getItem(exet.puz.id)
  if (!stored) {
    stored = {
      id: exet.puz.id,
      maxRevNum: 0,
      revs: []
    }
  } else {
    stored = JSON.parse(stored)
  }
  let exolve = exet.getExolve()
  if (stored.revs.length > 0) {
    let lastRev = stored.revs[stored.revs.length - 1]
    if (lastRev.exolve == exolve && lastRev.prefix == exet.prefix &&
        lastRev.suffix == exet.suffix) {
      return
    }
  }
  stored.maxRevNum++;
  let exetRev = new ExetRev(exet.puz.id, (exet.puz.title ? exet.puz.title : ''),
                            stored.maxRevNum, revType, Date.now(), details)
  exetRev.maxRevNum = stored.maxRevNum
  exetRev.prefix = exet.prefix
  exetRev.suffix = exet.suffix
  exetRev.exolve = exolve
  exetRev.scratchPad = exet.puz.scratchPad.value
  exetRev.navState = [exet.puz.currDir, exet.puz.currRow, exet.puz.currCol]
  stored.revs.push(exetRev)
  this.saveLocal(exet.puz.id, JSON.stringify(stored))
};

ExetRevManager.prototype.throttledSaveRev = function(revType, details="") {
  let urgent = revType <= 10;
  if (this.throttleRevTimer) {
    clearTimeout(this.throttleRevTimer);
    if (this.throttlingRevType > 0 && revType < this.throttlingRevType) {
      urgent = true
    }
  }
  this.throttleRevTimer = null;
  this.throttlingRevType = 0;
  if (urgent) {
    this.saveRev(revType, details)
    return
  }
  this.throttlingRevType = revType;
  this.throttleRevTimer = setTimeout(() => {
    this.saveRev(revType, details)
    this.throttleRevTimer = null;
    this.throttlingRevType = 0;
  }, this.saveLagMS);
}

function ExetRev(id, title, revNum, revType, timestamp, details="") {
  this.id = id;
  this.title = title
  this.revNum = revNum;
  this.revType = revType;
  this.timestamp = timestamp;
  this.details = details;
  // prefix, suffix, exolve should be set directly.
};

function Exet() {
  this.puz = null
  this.prefix = ''
  this.suffix = ''
  this.otherSections = ''

  // Start in the Exet tab
  this.currTab = "exet"
  this.savedIndsSelect = ""

  // State for throttled handlers
  this.throttledGridTimer = null;
  this.throttledClueTimer = null;
  this.throttledMetadataTimer = null;
  this.throttledCharadeTimer = null;
  this.viabilityUpdateTimer = null;
  this.inputLagMS = 400
  this.sweepMS = 500

  // Params for light choices shown.
  this.sweepMaxChoices = 500
  this.sweepMaxChoicesSmall = 4
  this.shownLightChoices = 200

  // Set of all letters in the lexicon.
  this.allLetters = {}
  for (let c of exetLexicon.letters) {
    this.allLetters[c.toUpperCase()] = true
  }
};

Exet.prototype.startNav = function(dir='A', row=0, col=0) {
  if (!this.puz) return;
  if (row < 0 || row >= this.puz.gridHeight ||
      col < 0 || col >= this.puz.gridWidth) {
    row = 0
    col = 0
  }
  if (dir != 'A' && dir != 'D') {
    dir = 'A'
    let gridCell = this.puz.grid[row][col]
    if (gridCell.isLight && !gridCell.acrossClueLabel &&
        gridCell.downClueLabel) {
      dir = 'D'
    }
  }
  this.puz.currRow = row
  this.puz.currCol = col
  this.puz.currDir = dir
  if (this.puz.grid[row][col].isLight) {
    this.puz.activateCell(row, col)
  } else {
    this.navDarkness(row, col)
  }
}

Exet.prototype.setPuzzle = function(puz) {
  if (puz.hasUnsolvedCells) {
    console.log('Can only load puzzles that have solutions specified. Use ? ' +
                'instead of 0 in grids under construction')
    return false
  }
  if (puz.hasDgmlessCells) {
    console.log('Diagramless cells not yet supported')
    return false
  }
  if (puz.hasNodirClues) {
    console.log('Nodir clues not yet supported')
    return false
  }
  if (puz.offNumClueIndices.length > 0) {
    console.log('Non-numeric clues not yet supported')
    return false
  }
  for (let i = 0; i < puz.gridHeight; i++) {
    for (let j = 0; j < puz.gridWidth; j++) {
      let gridCell = puz.grid[i][j]
      if (gridCell.skipNum) {
        console.log('Skipped-number cells not yet supported')
        return false
      }
    }
  }

  this.puz = puz
  puz.revealAll(false)
  puz.gridInput.addEventListener('keydown', this.handleKeyDown.bind(this));
  puz.gridInput.addEventListener('input', this.throttledGridInput.bind(this));
  if (!this.prefix && !this.suffix) {
    this.prefix = '' +
        '<!DOCTYPE html>\n' +
        '<html lang="en">\n' +
        '<head>\n' +
        '<meta charset="utf-8"/>\n' +
        '<meta name="viewport" content="width=device-width, initial-scale=1"/>\n' +
        '<link rel="stylesheet" type="text/css" href="https://viresh-ratnakar.github.io/exolve-m.css"/>\n' +
        '<script src="https://viresh-ratnakar.github.io/exolve-m.js"><\/script>\n' +
        '<\/head>\n' +
        '<body>\n' +
        '<script>\n' +
        'createExolve(`'
    this.suffix = '' +
        '`);\n' +
        '<\/script>\n' +
        '<\/body>\n' +
        '<\/html>\n'
  }
  this.otherSections = ''
  for (let l = 0; l < puz.numLines; l++) {
    if (puz.specLines[l].trim().startsWith('exolve-end')) {
      break
    }
    if (puz.specLines[l].trim().startsWith('exolve-id')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-title')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-setter')) {
      continue
    }
    if (puz.specLines[l].trim().startsWith('exolve-copyright')) {
      continue
    }
    if (puz.gridFirstLine && puz.gridLastLine &&
        l >= puz.gridFirstLine - 1 && l <= puz.gridLastLine) {
      continue
    }
    if (puz.acrossFirstLine && puz.acrossLastLine &&
        l >= puz.acrossFirstLine - 1 && l <= puz.acrossLastLine) {
      continue
    }
    if (puz.downFirstLine && puz.downLastLine &&
        l >= puz.downFirstLine - 1 && l <= puz.downLastLine) {
      continue
    }
    this.otherSections = this.otherSections + puz.specLines[l] + '\n'
  }
  let clueChanges = false
  let numA = 0
  let numD = 0
  for (let idx in puz.clues) {
    let clue = puz.clues[idx]
    if (clue.dir == 'A') numA++
    else if (clue.dir == 'D') numD++
    if (clue.parentClueIndex) {
      continue
    }
    if (!clue.clue) {
      clue.clue = 'TO DO: provide clue'
      if (clue.cells.length > 0) {
        clue.clue = clue.clue + ' (' + clue.cells.length + ')'
      }
      clueChanges = true
    }
  }
  if (clueChanges) {
    this.updatePuzzle(exetRevManager.REV_CLUE_CHANGE)
    return;
  }

  this.tabs = {
    "exet": {
      id: "exet",
      display: "Exet",
      hover: "Controls: load, save, grid-fill, edit, etc...",
      sections: [],
      url: "",
    },
    "tfd": {
      id: "tfd",
      display: "TFD",
      hover: "The Free Dictionary: definitions, roots, synonyms, US/UK pronunciations, encycolopedia...",
      sections: [{url: "https://thefreedictionary.com/"}],
    },
    "google": {
      id: "google",
      display: "Google Dict",
      hover: "Google Dictionary: definitions, synonyms, pronunciation...",
      sections: [{url: "https://api.dictionaryapi.dev/api/v1/entries/en/"}],
    },
    "etym": {
      id: "etym",
      display: "Etym",
      hover: "Etymonline: Roots and history...",
      sections: [{url: "https://www.etymonline.com/search?q="}],
    },
    "wordplay0": {
      id: "wordplay0",
      display: "Charades...",
      hover: "Charades, including anagrams, reversals, and containers...",
      sections: [{id: "xet-charades", maker: this.makeCharadeParam, title: "Charades, including anagrams, reversals, and containers"}],
    },
    "wordplay1": {
      id: "wordplay1",
      display: "Anagrams...",
      hover: "Nutrimatic: anagrams, alternations; composite anagrams...",
      sections: [
        {url: "https://nutrimatic.org/?q=", maker: this.makeAnagramParam, title: "Anagrams"},
        {url: "https://nutrimatic.org/?q=", maker: this.makeAlternationParam, title: "Alternations"},
        {id: "xet-companag", maker: this.makeCAParam, title: "Composite and extended anagrams"},
      ],
    },
    "wordplay2": {
      id: "wordplay2",
      display: "Hidden...",
      hover: "Nutrimatic: hidden answers...",
      sections: [
        {url: "https://nutrimatic.org/?q=", maker: this.makeHiddenParam, title: "Hidden answers"},
        {url: "https://nutrimatic.org/?q=", maker: this.makeRevHiddenParam, title: "Reversed hidden answers"},
      ]
    },
    "inds": {
      id: "inds",
      display: "Lists",
      hover: "Crossword Unclued, Wikipedia: cryptic indicators and abbreviations lists...",
      sections: [],
    },
  }

  this.replaceHandlers()
  document.getElementById(`${this.puz.prefix}-controls`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-saving`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-tools-link`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-report-bug`).style.display = 'none'
  document.getElementById(`${this.puz.prefix}-exolve-link`).style.display = 'none'

  this.copyright = document.getElementById(`${this.puz.prefix}-copyright`)
  this.copyright.innerHTML = `<span class="xet-action">Edit optional
      copyright notice: â’¸ &nbsp;</span><span
      class="xet-editable"
      id="xet-copyright" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.copyright}</span>`
  this.copyright.style.display = ''
  this.xetCopyright = document.getElementById('xet-copyright')

  this.title = document.getElementById(`${this.puz.prefix}-title`)
  this.title.innerHTML = `<span class="xet-action">Edit optional
      title:</span><span
      class="xet-editable"
      id="xet-title" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.title}</span>`
  this.title.style.display = ''
  this.xetTitle = document.getElementById('xet-title')

  this.setter = document.getElementById(`${this.puz.prefix}-setter`)
  this.setter.innerHTML = `<span class="xet-action">Edit optional
      setter(s):</span><span
      class="xet-editable"
      id="xet-setter" contenteditable=true
      oninput="exet.updateMetadata()">${this.puz.setter}</span>`
  this.setter.style.display = ''
  this.xetSetter = document.getElementById('xet-setter')

  let aLabel = document.getElementById(`${this.puz.prefix}-across-label`)
  aLabel.insertAdjacentHTML('beforeend', ` (${numA} clues)`)
  let dLabel = document.getElementById(`${this.puz.prefix}-down-label`)
  dLabel.insertAdjacentHTML('beforeend', ` (${numD} clues)`)

  this.frame = document.createElement('div')
  this.frame.className = 'xet-frame'
  this.frame.id = 'xet-frame'
  this.puz.gridPanel.after(this.frame)

  delete this.shownChoicesHash
  this.populateFrame()

  // Add darkness and viability indicators ("viablots").
  for (let i = 0; i < puz.gridHeight; i++) {
    for (let j = 0; j < puz.gridWidth; j++) {
      let gridCell = puz.grid[i][j]
      if (gridCell.isLight && gridCell.solution == '?') {
        const viablot =
            document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        viablot.setAttributeNS(
            null, 'cx', puz.cellLeftPos(j, puz.circleR + puz.GRIDLINE));
        viablot.setAttributeNS(
            null, 'cy', puz.cellTopPos(i, puz.circleR + puz.GRIDLINE));
        viablot.setAttributeNS(null, 'class', 'xlv-cell-circle');
        viablot.style.fill = 'transparent'
        viablot.setAttributeNS(null, 'r', puz.circleR * 0.1);
        gridCell.viablot = viablot
        puz.svg.appendChild(viablot)
        viablot.addEventListener('click', puz.cellActivator.bind(puz, i, j));
      } else if (!gridCell.isLight) {
        const border = 4
        let darkness =
          document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        darkness.setAttributeNS(null, 'x', this.puz.cellLeftPos(
            j, this.puz.GRIDLINE + border))
        darkness.setAttributeNS(null, 'y', this.puz.cellTopPos(
            i, this.puz.GRIDLINE + border))
        darkness.setAttributeNS(null, 'width',
                                this.puz.squareDim - (2 * border));
        darkness.setAttributeNS(null, 'height',
                                this.puz.squareDim - (2 * border));
        darkness.style.fill = 'transparent'
        puz.svg.appendChild(darkness)
        gridCell.darkness = darkness
        darkness.addEventListener('click', this.navDarkness.bind(this, i, j))
      }
    }
  }

  // Display lexicon info
  const status = document.getElementById(`${this.puz.prefix}-status`)
  status.insertAdjacentHTML('beforeend', `<span> Lexicon: ${exetLexicon.id} ${exetLexicon.language} ${exetLexicon.script}.</span>`)

  // Display sweeping activity indicator
  const gridParent = document.getElementById(`${this.puz.prefix}-grid-parent`)
  gridParent.insertAdjacentHTML('beforeend',
    `<div class="xet-sweeping-box"
       title="When there is a flashing red circle here, Exet is pruning away non-viable grid-fill suggestions in the background">
       <div class="xet-sweeping" id="xet-sweeping"></div></div>`)
  this.sweepIndicator = document.getElementById('xet-sweeping')

  this.updateViability();

  return true
}

Exet.prototype.makeExetTab = function() {
  let exetTab = this.tabs["exet"]
  exetTab.content.innerHTML = `
<div class="xet-controls-col">
  <div class="xet-menu">
    <ul>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to open a new or previously saved puzzle">Open</div>
        <div class="xet-dropdown-content">
          <div class="xet-dropdown-item" id="xet-show-puz-chooser">
            Choose a puzzle previously opened with Exet
          </div>
          <div class="xet-dropdown-item" id="xet-show-rev-chooser">
            Go back to a specific revision of the current puzzle
          </div>
          <div class="xet-dropdown-item">
            Open Exolve file: <input id="xet-file" onchange="exetLoadFile();" type="file"></input>
          </div>
          <div class="xet-dropdown-item">
            New grid:
            <div class="xet-dropdown-submenu">
              <div style="padding:4px;text-align:center">
                <div>
                  <input id="xet-w" name="xet-w" value="15"
                    type="text" size="3" maxlength="3" placeholder="W">
                  </input>
                  &times;
                  <input id="xet-h" name="xet-h" value="15"
                    type="text" size="3" maxlength="3" placeholder="H">
                  </input>
                </div>
                <br>
                <div>
                  Unique ID:
                  <input id="xet-id" name="xet-id"
                    value="xet-${Math.random().toString(36).substring(2, 8)}"
                    title="Please change to a meaningful alphanumeric id (beginning with a letter) to identify easily later"
                    type="text" size="15" maxlength="30" placeholder="alphanumeric unique id">
                  </input>
                </div>
                <br>
                <div title="When this is checked, Exet will automagically add blocked cells to create a valid grid. You can further edit the blocks and add more automagic blocks from the Edit menu">
                  Add automagic blocks:
                  <input id="xet-autoblock" name="xet-autoblock" value="autoblock" checked=true type="checkbox">
                  </input>
                </div>
              </div>
              <hr>
              <div class="xet-controls-row">
                <div class="xet-dropdown-subitem" title="Blocked with no top/left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, false, false);">
                  <img class="xet-icon" src="no-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="Blocked with top but not left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, true, false);">
                  <img class="xet-icon" src="t-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="Blocked with left but not top unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, false, true);">
                  <img class="xet-icon" src="l-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="Blocked with top/left unches"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  true, true, true);">
                  <img class="xet-icon" src="tl-unches.png"/>
                </div>
                <div class="xet-dropdown-subitem" title="No blocks"
                  onclick="exetBlank(document.getElementById('xet-w').value, document.getElementById('xet-h').value, document.getElementById('xet-id').value, document.getElementById('xet-autoblock').checked,  false);">
                  <img class="xet-icon" src="no-blocks.png"/>
                </div>
              </div>
            </div>
          </div>
          <div class="xet-dropdown-item" id="xet-manage-storage">
            Manage storage (Used:
            ${exetRevManager.inMB(exetRevManager.spaceUsed)} MB
            Available: 
              <span class="xet-red">${exetRevManager.inMB(exetRevManager.spaceUsedAtStart + exetRevManager.spaceLeftAtStart - exetRevManager.spaceUsed)}</span> MB)
          </div>
        </div>
      </li>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to save, with some formatting options">Save</div>
        <div class="xet-dropdown-content">
          <div class="xet-dropdown-item" onclick="exet.downloadDotPuz()">Download PUZ file (exet.puz)</div>
          <div class="xet-dropdown-item" onclick="exet.download(true)">Download Exolve file w/ solutions (exet-exolve-solved.html)</div>
          <div class="xet-dropdown-item" onclick="exet.download(false)">Download Exolve file w/o solutions (exet-exolve-unsolved.html)</div>
          <div class="xet-dropdown-item" onclick="exet.toClipboard(true, 'xet-xlv-widget')">Copy Exolve widget code w/ solutions &#128203;
            <div class="xet-dropdown-submenu">
              <textarea rows="100" cols="80" id="xet-xlv-widget">
              </textarea>
            </div>
          </div>
          <div class="xet-dropdown-item" onclick="exet.toClipboard(false, 'xet-xlv-widget-nosol')">Copy Exolve widget code w/o solutions &#128203;
            <div class="xet-dropdown-submenu">
              <textarea rows="100" cols="80" id="xet-xlv-widget-nosol">
              </textarea>
            </div>
          </div>
        </div>
      </li>
      <li class="xet-dropdown">
        <div class="xet-dropbtn" title="Click to make grid changes (please also note the listed keyboard shortcuts)">Edit</div>
        <div class="xet-dropdown-content">
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('@')">Toggle encircling (@)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('!')">Toggle marking prefilled (!)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('.')">Toggle block (.)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('|')">Toggle bar-after (|)</div>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('_')">Toggle bar-under (_)</div>
          <hr>
          <hr>
          <div title="Try to autmatically add random blocks while maintaining a valid grid"
            class="xet-dropdown-item" onclick="exet.handleKeyDown('#')">Add automagic blocks (#)</div>
          <hr>
          <hr>
          <div class="xet-dropdown-item" onclick="exet.handleKeyDown('=')">Accept forced fills (=)</div>
          <div class="xet-dropdown-item" onclick="exet.puz.clearAll()">Clear all the lights!</div>
        </div>
      </li>
      <li class="xet-dropdown" style="float:right;">
        <div class="xet-dropbtn" title="Click to see Motes, notices, and pointers about Exet...">About</div>
        <div class="xet-dropdown-content" style="right:0;width:90ch;padding:8px;">
          <iframe id="xet-about-iframe" class="xet-iframe"
              style="height:450px"
              src="about-exet.html">
          </iframe>
        </div>
      </li>
    </ul>
    <div id="xet-rev-chooser" class="xet-rev-chooser" style="display:none">
    </div>
  </div>
  <hr class="xet-full-width"/>
  <div id="xet-temp" style="display:none">
  </div>

  <div class="xet-controls-row xet-panel xet-high-tall-box">
    <div class="xet-controls-col">
      <div>
        <span style="font-weight:bold" title="Please note that any lexicon in use by this software is inevitably likely to have some errors and omissions.">Choose grid-fill</span>
        <button class="xlv-small-button" style="padding:5px 4px" onclick="exet.puz.clearCurr()">Clear light</button>
      </div>
      <div class="xet-choices-box" id="xet-light-choices-box">
        <table id="xet-light-choices" class="xet-choices">
        </table>
      </div>
    </div>
    <div class="xet-controls-col">
      <div id="xet-scratch-pad" class="xet-controls-col">
      </div>
    </div>
  </div>
</div>
  `;
  // Set up menu click handling
  let menuButtons = exetTab.content.getElementsByClassName('xet-dropbtn')
  for (let i = 0; i < menuButtons.length; i++) {
    let menuPanel = menuButtons[i].nextElementSibling
    menuButtons[i].addEventListener('click', e => {
      exetModals.showModal(menuPanel)
      e.stopPropagation()
    })
    menuButtons[i].addEventListener('mouseenter', e => {
      exetModals.hide()
    })
  }

  this.lightChoices = document.getElementById("xet-light-choices")
  this.revChooser = document.getElementById("xet-rev-chooser")
  let showPuzChooser = document.getElementById("xet-show-puz-chooser")
  showPuzChooser.addEventListener('click', e => {
    exetRevManager.choosePuzRev(false, null, exet.revChooser, exetFromHistory);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })
  let showRevChooser = document.getElementById("xet-show-rev-chooser")
  showRevChooser.addEventListener('click', e => {
    exetRevManager.choosePuzRev(false, this.puz, exet.revChooser, exetFromHistory);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })
  let manageStorage = document.getElementById("xet-manage-storage")
  manageStorage.addEventListener('click', e => {
    exetRevManager.choosePuzRev(true, null, exet.revChooser, null);
    exetModals.showModal(exet.revChooser)
    e.stopPropagation()
  })

  // Move the scratch pad over to here.
  const scratchP = document.getElementById("xet-scratch-pad")
  this.puz.scratchPad.rows = "3"
  this.puz.scratchPad.cols = "82"
  const scratchPLabel = document.getElementById(this.puz.prefix + '-shuffle')
  scratchPLabel.style.padding = '8px 0'
  scratchP.appendChild(scratchPLabel)
  scratchP.appendChild(this.puz.scratchPad)

  // Pull in the clues.
  this.cluesPanel = document.createElement('div')
  this.cluesPanel.id = 'xet-clues'
  this.cluesPanel.className = 'xet-panel xet-mid-tall-box xet-clues'
  this.cluesPanel.title = 'You can edit the current clue as shown above the grid by clicking on it.'
  scratchP.after(this.cluesPanel)
  this.cluesPanel.appendChild(document.getElementById(`${this.puz.prefix}-clues`))
}

Exet.prototype.stripInputLF = function(inp) {
  if (!inp) return
  if (inp.innerText.indexOf('\n') < 0) return
  inp.innerText = inp.innerText.replace(/\n/g, ' ')
}

Exet.prototype.updateMetadata = function() {
  if (!this.puz) {
    return
  }
  if (this.throttledMetadataTimer) {
    clearTimeout(this.throttledMetadataTimer);
  }
  this.throttledMetadataTimer = setTimeout(() => {
    if (this.xetTitle) {
      this.stripInputLF(this.xetTitle)
      this.puz.title = this.xetTitle.innerText
    }
    if (this.xetSetter) {
      this.stripInputLF(this.xetSetter)
      this.puz.setter = this.xetSetter.innerText
    }
    if (this.xetCopyright) {
      this.stripInputLF(this.xetCopyright)
      this.puz.copyright = this.xetCopyright.innerText
    }
    this.throttledMetadataTimer = null;
    exetRevManager.throttledSaveRev(exetRevManager.REV_METADATA_CHANGE)
  }, 2000);
}

Exet.prototype.indsTabNav = function() {
  if (this.indsIframe.src == this.indsSelect.value) {
    return
  }
  this.indsIframe.src = this.indsSelect.value;
  this.indsUrl.innerText = this.indsSelect.value;
  this.indsUrl.href = this.indsSelect.value;
}

Exet.prototype.makeIndsTab = function(panelH) {
  let inds = [
    {name: "Please select", url: ""},
    {name: "Crossword Unclued's anagram indicators",
     url: "https://www.crosswordunclued.com/2008/09/anagram-indicators.html"},
    {name: "Crossword Unclued's hidden words indicators",
     url: "https://www.crosswordunclued.com/2009/03/hidden-word-indicators.html"},
    {name: "Crossword Unclued's containment indicators",
     url: "https://www.crosswordunclued.com/2009/02/container-and-content-indicators.html"},
    {name: "Crossword Unclued's reversal indicators",
     url: "https://www.crosswordunclued.com/2009/07/reversal-indicators.html"},
    {name: "Crossword Unclued's homophone indicators",
     url: "https://www.crosswordunclued.com/2009/02/homophone-indicators.html"},
    {name: "Crossword Unclued's deletion indicators",
     url: "https://www.crosswordunclued.com/2009/04/deletion-indicators.html"},
    {name: "Crossword Unclued's letter-picking indicators",
     url: "https://www.crosswordunclued.com/2009/04/letter-sequence-indicators.html"},
    {name: "Crossword Unclued's list of abbreviations",
     url: "https://www.crosswordunclued.com/2008/10/cryptic-abbreviations.html"},
    {name: "Wikipedia's list of abbreviations",
     url: "https://en.wikipedia.org/wiki/Crossword_abbreviations"},
  ]
  let indsTab = this.tabs["inds"]
  let html = `
  <div>
  <select name="xet-inds-select" id="xet-inds-select"
    onchange="exet.indsTabNav()">`
  for (let ind of inds) {
    html = html + `
    <option value="${ind.url}">${ind.name}</option>`
  }
  html = html + '</select></div><br>'
  html = html + `
  <a href="" target="_blank" id="xet-inds-choice-url" class="xet-blue xet-small"></a><br>
  <iframe id="xet-inds-iframe" class="xet-iframe" src=""
    style="height:${panelH}px" height="${panelH}"></iframe>
  `;
  indsTab.content.innerHTML = html;
  this.indsIframe = document.getElementById('xet-inds-iframe')
  this.indsSelect = document.getElementById('xet-inds-select')
  this.indsSelect.value = this.savedIndsSelect
  this.indsUrl = document.getElementById('xet-inds-choice-url')
}

Exet.prototype.getAllSplits = function(fodder, k) {
  let n = fodder.length
  if (n < 1 || k < 1 || k > n ) return []
  if (k == 1) {
    return [[fodder]]
  }
  if (k == n) {
    let pieces = []
    for (let i = 0; i < n; i++) {
      pieces.push(fodder.charAt(i))
    }
    return [pieces]
  }
  let splits = []
  // For long fodders, skip some splits.
  for (let last_span = (fodder.length > 10 ? fodder.length - 9 : 1);
       last_span <= n - k + 1; last_span++) {
    let last_piece = fodder.substr(n - last_span, last_span);
    let prefix = fodder.substr(0, n - last_span);
    let subsplits = this.getAllSplits(prefix, k - 1)
    for (let subsplit of subsplits) {
      subsplit.push(last_piece);
      splits.push(subsplit);
    }
  }
  return splits
}

Exet.prototype.pushCharadeCandidate = function(elements) {
  if (!elements || elements.length == 0) {
    return
  }
  let charade = ''
  let score = 0;
  let i = 0
  let numScores = elements.length
  while (i < elements.length) {
    let x = elements[i]
    if (!x.possible) {
      return
    }
    if (charade) charade = charade + '<span class="xet-blue"> + </span>'
    charade = charade + x.possible
    score += x.score
    i++
    if (x.container) {
      contents = ''
      while (i < x.container) {
        let y = elements[i]
        if (!y.possible) {
          return
        }
        if (contents) contents = contents + ' '
        contents = contents + y.possible
        score += y.score
        i++
      }
      charade = charade + ' <span class="xet-blue">around (</span>' + contents +
        '<span class="xet-blue">)</span>'
      i++
      numScores = elements.length - 1
    }
  }
  score = score / numScores
  if (charade) {
    this.charadeCandidates.push({
      charade: charade,
      score: score
    })
  }
}

Exet.prototype.updateCharades = function(fodder) {
  if (this.throttledCharadeTimer) {
    clearTimeout(this.throttledCharadeTimer);
  }
  this.throttledCharadeTimer = null
  this.charadeCandidates = []
  this.charadeParts = 1;
  this.charadeSplits = null;
  this.charadeSplitIndex = 0;
  this.charadeMax = Math.min(fodder.length, 4)
  this.charadeFodder = fodder
  this.updateCharadesPartial()
}

Exet.prototype.updateCharadesPartial = function(work=100, sleep=50) {
  let startTS = Date.now()
  while (this.charadeParts <= this.charadeMax) {
    if (!this.charadeSplits) {
      this.charadeSplits = this.getAllSplits(this.charadeFodder, this.charadeParts)
      this.charadeSplitIndex = 0
    }
    while (this.charadeSplitIndex < this.charadeSplits.length) {
      let split = this.charadeSplits[this.charadeSplitIndex]
      let viable = []
      for (let part of split) {
        let possible = ''
        let score = 0
        let choices = this.getAnagrams(part)
        if (choices.length > 0) {
          score = part.length
          let rpart = ''
          if (part.length > 1) {
            rpart = part.split('').reverse().join('')
          }
          for (let choice of choices) {
            if (possible) possible = possible + ', '
            let key = this.makeCharadeParam(choice)
            if (key == part) possible = possible + choice
            else if (key == rpart) possible = possible + choice + '<span class="xet-blue"><<</span>'
            else possible = possible + choice + '<span class="xet-blue">*</span>'
          }
          if (choices.length > 1) {
            possible = '<span class="xet-blue">[</span>' + possible + '<span class="xet-blue">]</span>'
          }
        }
        viable.push({possible: possible, score: score})
      }
      if (viable.length < this.charadeParts) {
        continue
      }
      this.pushCharadeCandidate(viable)
      for (let c1 = 0; c1 < this.charadeParts - 2; c1++) {
        for (let c2 = c1 + 2; c2 < this.charadeParts; c2++) {
          // Everything else must be viable
          let ok = true
          for (let i = 0; i < this.charadeParts; i++) {
            if (i != c1 && i != c2 && !viable[i].possible) {
              ok = false
              break
            }
          }
          if (!ok) {
            continue
          }
          let container = split[c1] + split[c2]
          let choices = this.getAnagrams(container)
          if (choices.length > 0) {
            let rcontainer = container.split('').reverse().join('')
            let possible = ''
            for (let choice of choices) {
              if (possible) possible = possible + ', '
              let key = this.makeCharadeParam(choice)
              if (key == container) possible = possible + choice
              else if (key == rcontainer) possible = possible + choice + '<span class="xet-blue"><<</span>'
              else possible = possible + choice + '<span class="xet-blue">*</span>'
            }
            if (choices.length > 1) {
              possible = '<span class="xet-blue">[</span>' + possible + '<span class="xet-blue">]</span>'
            }
            let vcopy = viable.slice(0, viable.length)
            vcopy[c1] = {}
            vcopy[c1].possible = possible
            vcopy[c1].score = container.length
            vcopy[c1].container = c2
            this.pushCharadeCandidate(vcopy)
          }
        }
      }
      this.charadeSplitIndex++
      if (Date.now() - startTS >= work) {
        break
      }
    }
    if (this.charadeSplitIndex == this.charadeSplits.length) {
      this.charadeSplits = null
      this.charadeParts++;
    }
    if (Date.now() - startTS >= work) {
      break
    }
  }
  let candidates = this.charadeCandidates.sort((a, b) => b.score - a.score);
  let html = '<table id="xet-charade-choices">'
  for (let candidate of candidates) {
    html = html + `
      <tr><td><span style="color:gray">[${candidate.score.toFixed(1)}]</span> ${candidate.charade}</td></tr>`
  }
  html = html + '</table>'
  this.charades.innerHTML = html;
  if (this.charadeParts <= this.charadeMax) {
    this.throttledCharadeTimer = setTimeout(() => {
      this.updateCharadesPartial(work, sleep)
    }, sleep);
  }
}

Exet.prototype.updateCA = function() {
  let fodder = this.caFodder.value.toLowerCase().replace(/[^a-z]/g, '').split('').sort()
  let anagram = this.caAnagram.value.toLowerCase().replace(/[^a-z]/g, '').split('').sort()
  let f = 0;
  let a = 0;
  let extra = []
  let unused = []
  while (f < fodder.length && a < anagram.length) {
    if (fodder[f] == anagram[a]) {
      f++;
      a++;
    } else if (fodder[f] < anagram[a]) {
      unused.push(fodder[f++])
    } else {
      extra.push(anagram[a++])
    }
  }
  while (f < fodder.length) {
    unused.push(fodder[f++])
  }
  while (a < anagram.length) {
    extra.push(anagram[a++])
  }
  extraS = extra.join('')
  this.caExtra.innerText = extraS
  let html = ''
  let extraAnags = this.getAnagrams(extraS)
  for (let choice of extraAnags) {
    html = html + `
      <tr><td>${choice}</td></tr>`
  }
  this.caExtraAnags.innerHTML = html
  unusedS = unused.join('')
  this.caUnused.innerText = unusedS
  html = ''
  let unusedAnags = this.getAnagrams(unusedS)
  for (let choice of unusedAnags) {
    html = html + `
      <tr><td>${choice}</td></tr>`
  }
  this.caUnusedAnags.innerHTML = html
}

Exet.prototype.populateCompanag = function() {
  let ca = document.getElementById('xet-companag')
  ca.className = 'xet-companag'
  ca.innerHTML = `
    <table class="xet-table-midline">
      <tr>
        <td class="xet-td">Fodder:</td>
        <td class="xet-td">Anagram:</td>
      </tr>
      <tr>
        <td class="xet-td"><input type="text" class="xlv-answer xet-companag-text" id='xet-ca-fodder'></input></td>
        <td class="xet-td"><input type="text"
          title="Enter a phrase that's only roughly an anagram of some of the letters in the fodder"
          class="xlv-answer xet-companag-text" id='xet-ca-anagram'></input></td>
      </tr>
      <tr>
        <td class="xet-td">Extra in anagram:</td>
        <td class="xet-td"><div>Unused from fodder:</td>
      </tr>
      <tr>
        <td class="xet-td"><div class="xet-companag-text" id='xet-ca-extra'></div></td>
        <td class="xet-td"><div class="xet-companag-text" id='xet-ca-unused'></div></td>
      </tr>
      <tr>
        <td class="xet-td">
          Extra* anagrams:
          <table id="xet-ca-extra-anags">
          </table>
        </td>
        <td class="xet-td">
          Unused* anagrams:
          <table id="xet-ca-unused-anags">
          </table>
        </td>
      </tr>
    </table>`
  this.caFodder = document.getElementById('xet-ca-fodder')
  this.caAnagram = document.getElementById('xet-ca-anagram')
  this.caExtra = document.getElementById('xet-ca-extra')
  this.caUnused = document.getElementById('xet-ca-unused')
  this.caFodder.addEventListener('input', this.updateCA.bind(this))
  this.caAnagram.addEventListener('input', this.updateCA.bind(this))
  this.caExtraAnags = document.getElementById('xet-ca-extra-anags')
  this.caUnusedAnags = document.getElementById('xet-ca-unused-anags')
}

Exet.prototype.populateFrame = function() {
  let frameHTML = ''
  frameHTML = frameHTML + '<div class="xet-tab">'
  for (let id in this.tabs) {
    let tab = this.tabs[id]
    frameHTML = frameHTML +
        `<button id="xet-${id}">${tab.display}</button>`
  }
  frameHTML = frameHTML + '</div>'

  const panelH = 500
  const panelInnerH = 450
  for (let id in this.tabs) {
    let tab = this.tabs[id]
    frameHTML = frameHTML + `<div class="xet-tabcontent" id="xet-${id}-frame">`
    if (tab.sections.length > 0) {
      // We show the first (presumably main) section in the left column,
      // and stack up all the other sections in the right column.
      let numRows = 1
      let panelW = 900
      let secondH = panelInnerH
      if (tab.sections.length > 1) {
        numRows = tab.sections.length - 1
        panelW = 440
      }
      if (numRows > 1) {
        secondH = 200
      }
      frameHTML = frameHTML + '<div class="xet-section"><table>'
      for (let i = 0; i < tab.sections.length; i++) {
        let section = tab.sections[i]
        if (i != 1) {
          frameHTML = frameHTML + '<tr>'
        }
        let h = secondH
        if (i == 0) {
          frameHTML = frameHTML + `<td class="xet-td" rowspan="${numRows}">`
          h = panelInnerH
        } else {
          frameHTML = frameHTML + '<td class="xet-td">'
        }
        if (section.url) {
          frameHTML = frameHTML + `
            <div class="xet-bold">${section.title || ''}</div>
            <a href="" target="_blank" id="xet-${id}-url-${i}" class="xet-blue xet-small"></a><br>
            <iframe class="xet-iframe" style="height:${h}px;width:${panelW}px;"
               height="${h}" width="${panelW}px" id="xet-${id}-content-${i}">
            </iframe>`
        } else {
          frameHTML = frameHTML + `
            <div class="xet-bold">${section.title || ''}</div>
            <div id=${section.id}
              class="xet-panel"
              style="height:${h}px;width:${panelW}px;">
            </div>`
        }
        if (i > 0 && i < tab.sections.length - 1) {
          frameHTML = frameHTML + '<hr/><br>'
        }
        frameHTML = frameHTML + '</td>'
        if (i > 0 || tab.sections.length == 1) {
          frameHTML = frameHTML + '</tr>'
        }
      }
      frameHTML = frameHTML + `
        </table>
        </div>`
    } else {
      frameHTML = frameHTML + `
        <div class="xet-section" id="xet-${id}-content"></div>`
    }
    frameHTML = frameHTML + '</div>'
  }
  this.frame.innerHTML = frameHTML

  for (let id in this.tabs) {
    let tab = this.tabs[id]
    tab.button = document.getElementById(`xet-${id}`)
    tab.button.title = tab.hover
    tab.button.addEventListener(
      'click', this.handleTabClick.bind(this, id));
    tab.frame = document.getElementById(`xet-${id}-frame`)
    if (tab.sections.length > 0) {
      for (let i = 0; i < tab.sections.length; i++) {
        let section = tab.sections[i]
        if (!section.url) {
          continue
        }
        section.content = document.getElementById(`xet-${id}-content-${i}`)
        section.urldisp = document.getElementById(`xet-${id}-url-${i}`)
      }
    } else {
      tab.content = document.getElementById(`xet-${id}-content`)
    }
  }
  let ch = document.getElementById('xet-charades')
  ch.innerHTML = `
    <div id="xet-charades-box" style="margin:16px 0;border:0">
    </div>
  `
  this.charades = document.getElementById('xet-charades-box')
  this.populateCompanag()

  this.makeExetTab()
  this.makeIndsTab(panelInnerH)
}

Exet.prototype.download = function(solved=true) {
  let html = this.getHTML(solved)
  const a = document.createElement("a");
  a.style.display = "none";
  document.body.appendChild(a);
  a.href = window.URL.createObjectURL(
    new Blob([html], {type: "text/html"})
  );
  a.setAttribute("download", solved ? "exet-exolve-solved.html" :
    "exet-exolve-unsolved.html");
  a.click();
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  exetModals.hide()
}

Exet.prototype.toClipboard = function(solved=true, inpid) {
  const inp = document.getElementById(inpid);

  let prefix = '' +
      '<link rel="stylesheet" type="text/css" href="https://viresh-ratnakar.github.io/exolve-m.css"/>\n' +
      '<script src="https://viresh-ratnakar.github.io/exolve-m.js">\n' +
      '<\/script>\n' +
      '<div id="exolve">\n' +
      '<\/div>\n' +
      '<script>\n' +
      '  createExolve(`\n';
  let suffix = '' +
      '  `);\n' +
      '<\/script>\n'
  inp.value = prefix + this.getExolve('', false, solved) + suffix

  inp.select();
  inp.setSelectionRange(0, 99999);
  document.execCommand("copy");
  setTimeout(() => {
    inp.value = ''
    exetModals.hide()
  }, 1000);
}

Exet.prototype.dotPuzCksum = function(uint8array, offset, len, cksum) {
  for (let i = 0; i < len; i++) {
    if (cksum & 0x0001) {
      cksum = (cksum >> 1) | 0x8000;
    } else {
      cksum = cksum >> 1;
    }
    cksum += uint8array[offset + i]
    cksum = cksum & 0xffff
  }
  return cksum;
}

Exet.prototype.dotPuzShort = function(buffer, offset, shortval) {
  buffer[offset] = shortval & 0xFF
  buffer[offset + 1] = shortval >> 8
}

Exet.prototype.getDotPuz = function() {
  // Generously estimate length of the buffer needed.
  let exolve = this.getExolve();
  let estDotPuzLen = 2 * (1000 + exolve.length)
  let buffer = new Uint8Array(estDotPuzLen);
  let offset = 0;

  let encoder = new TextEncoder("utf-8")

  offset = 0x02
  let fileMagic = encoder.encode("ACROSS&DOWN")
  for (let x of fileMagic) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  offset = 0x18
  let ver = encoder.encode("1.3")
  for (let x of ver) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  offset = 0x2c
  buffer[offset++] = this.puz.gridWidth
  buffer[offset++] = this.puz.gridHeight

  this.dotPuzShort(buffer, 0x2E, this.puz.allClueIndices.length)
  buffer[0x30] = 1  // Unknown bitmask

  let numCells = this.puz.gridWidth * this.puz.gridHeight;

  let solution = ''
  let playerState = ''
  let orderedClueIndices = []
  let circleLocs = []
  for (let i = 0; i < this.puz.gridHeight; i++) {
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (gridCell.hasBarAfter || gridCell.hasBarUnder) {
        alert('This puzzle has barred cells and cannot be saved .PUZ');
        return null
      }
      if (!gridCell.isLight) {
        solution = solution + '.'
        playerState = playerState + '.'
      } else {
        solution = solution + (gridCell.currLetter != '0' ?
          gridCell.currLetter : '?')
        playerState = playerState + '-'
        if (gridCell.startsAcrossClue) {
          orderedClueIndices.push('A' + gridCell.startsClueLabel)
        }
        if (gridCell.startsDownClue) {
          orderedClueIndices.push('D' + gridCell.startsClueLabel)
        }
        if (gridCell.hasCircle) {
          circleLocs.push((i * this.puz.gridWidth) + j)
        }
      }
    }
  }
  if (this.puz.allClueIndices.length != orderedClueIndices.length) {
    alert('This puzzle has clue types that cannot be saved as .PUZ');
    return null
  }
  solution = encoder.encode(solution)
  playerState = encoder.encode(playerState)

  offset = 0x34
  for (let x of solution) {
    buffer[offset++] = x
  }
  for (let x of playerState) {
    buffer[offset++] = x
  }

  let titleOffset = offset
  let utf8Title = encoder.encode(this.puz.title)
  for (let x of utf8Title) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  let setterOffset = offset
  let utf8Setter = encoder.encode(this.puz.setter)
  for (let x of utf8Setter) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  let copyrightOffset = offset
  let utf8Copyright = encoder.encode(this.puz.copyright)
  for (let x of utf8Copyright) {
    buffer[offset++] = x
  }
  buffer[offset++] = 0

  let clueOffsets = []
  let clueLens = []
  for (let ci of orderedClueIndices) {
    let theClue = this.puz.clues[ci]
    if (theClue.parentClueIndex) {
      alert('This puzzle has linked clues and cannot be saved as .PUZ');
      return null
    }
    let utf8Clue = encoder.encode(theClue.clue)
    clueOffsets.push(offset)
    clueLens.push(utf8Clue.length)
    for (let x of utf8Clue) {
      buffer[offset++] = x
    }
    buffer[offset++] = 0
  }
  // Empty Notes section:
  buffer[offset++] = 0

  let gextOffset = -1
  if (circleLocs.length > 0) {
    gextOffset = offset
    let secName = "GEXT"
    for (let x of secName) {
      buffer[offset++] = x
    }
    this.dotPuzShort(buffer, offset, numCells);
    offset += 4
    for (let loc of circleLocs) {
      buffer[offset + loc] = 0x80
    }
    offset += numCells
    buffer[offset++] = 0
    let c_gext = this.dotPuzCksum(buffer, gextOffset + 8, numCells, 0);
    this.dotPuzShort(buffer, gextOffset + 6, c_gext);
  }

  // Need to fill checksums
  let c_cib = this.dotPuzCksum(buffer, 0x2C, 8, 0);
  this.dotPuzShort(buffer, 0x0E, c_cib);

  let cksum = c_cib;
  cksum = this.dotPuzCksum(buffer, 0x34, numCells, cksum);
  cksum = this.dotPuzCksum(buffer, 0x34 + numCells, numCells, cksum);

  if (utf8Title.length > 0) {
    cksum = this.dotPuzCksum(buffer, titleOffset, utf8Title.length + 1, cksum);
  }
  if (utf8Setter.length > 0) {
    cksum = this.dotPuzCksum(buffer, setterOffset, utf8Setter.length + 1, cksum);
  }
  if (utf8Copyright.length > 0) {
    cksum = this.dotPuzCksum(buffer, copyrightOffset, utf8Copyright.length + 1, cksum);
  }

  for (let i = 0; i < orderedClueIndices.length; i++) {
    cksum = this.dotPuzCksum(buffer, clueOffsets[i], clueLens[i], cksum);
  }
  this.dotPuzShort(buffer, 0x00, cksum);

  let c_sol = this.dotPuzCksum(buffer, 0x34, numCells, 0);
  let c_grid = this.dotPuzCksum(buffer, 0x34 + numCells, numCells, 0);
  let c_part = 0;
  if (utf8Title.length > 0) {
    c_part = this.dotPuzCksum(buffer, titleOffset, utf8Title.length + 1, c_part);
  }
  if (utf8Setter.length > 0) {
    c_part = this.dotPuzCksum(buffer, setterOffset, utf8Setter.length + 1, c_part);
  }
  if (utf8Copyright.length > 0) {
    c_part = this.dotPuzCksum(buffer, copyrightOffset, utf8Copyright.length + 1, c_part);
  }
  for (let i = 0; i < orderedClueIndices.length; i++) {
    c_part = this.dotPuzCksum(buffer, clueOffsets[i], clueLens[i], c_part);
  }

  buffer[0x10] = 0x49 ^ (c_cib & 0xFF);
  buffer[0x11] = 0x43 ^ (c_sol & 0xFF);
  buffer[0x12] = 0x48 ^ (c_grid & 0xFF);
  buffer[0x13] = 0x45 ^ (c_part & 0xFF);

  buffer[0x14] = 0x41 ^ ((c_cib & 0xFF00) >> 8);
  buffer[0x15] = 0x54 ^ ((c_sol & 0xFF00) >> 8);
  buffer[0x16] = 0x45 ^ ((c_grid & 0xFF00) >> 8);
  buffer[0x17] = 0x44 ^ ((c_part & 0xFF00) >> 8); 

  return buffer.slice(0, offset)
}

Exet.prototype.downloadDotPuz = function() {
  let dotPuz = this.getDotPuz()
  if (!dotPuz) {
    exetModals.hide()
    return
  }
  const a = document.createElement("a");
  a.style.display = "none";
  document.body.appendChild(a);
  a.href = window.URL.createObjectURL(
    new Blob([dotPuz], {type: "application/x-crossword"})
  );
  a.setAttribute("download", "exet.puz");
  a.click();
  window.URL.revokeObjectURL(a.href);
  document.body.removeChild(a);
  exetModals.hide()
}

Exet.prototype.makeWordParam = function(s) {
  return s.toLowerCase()
}

Exet.prototype.makeCharadeParam = function(s) {
  return s.toLowerCase().replace(/\?/g, '').replace(/[^a-z]/g, '')
}

Exet.prototype.makeAnagramParam = function(s) {
  s = this.makeCharadeParam(s)
  return "<" + s + ">"
}

Exet.prototype.makeCAParam = function(s) {
  return s.toLowerCase().replace(/\?/g, '')
}

Exet.prototype.makeAlternationParam = function(s) {
  s = this.makeCharadeParam(s)
  let out = 'A%3F'
  for (let c of s) {
    out = out + c + 'A'
  }
  return out + '%3F'
}

Exet.prototype.makeHiddenParam = function(s) {
  s = this.makeCharadeParam(s)
  if (s.length < 2) return s
  return 'A*"A' + s.charAt(0) + '"' + s.substr(1, s.length - 2) + '"' + s.charAt(s.length - 1) + 'A"A*'
}

Exet.prototype.makeRevHiddenParam = function(s) {
  s = this.makeCharadeParam(s)
  if (s.length < 2) return s
  let sr = ''
  for (let i = s.length - 1; i >= 0; i--) {
    sr = sr + s.charAt(i)
  }
  return 'A*"A' + sr.charAt(0) + '"' + sr.substr(1, sr.length - 2) + '"' + sr.charAt(sr.length - 1) + 'A"A*'
}

Exet.prototype.handleTabClick = function(id) {
  let tab = this.tabs[id]
  if (!tab) {
    return
  }
  this.currTab = id
  for (let x in this.tabs) {
    let xtab = this.tabs[x]
    xtab.frame.style.display = "none"
    xtab.button.className = xtab.button.className.replace(" active", "");
  }

  tab.frame.style.display = "block";
  tab.button.className += " active";

  if (id == "exet") {
    return
  }
  if (id == "inds") {
    this.indsTabNav();
    return
  }

  let ci = this.puz.currClueIndex
  if (!ci) {
    return
  }
  let words = this.puz.clues[ci].solution
  if (!words) {
    return
  }
  for (let i = 0; i < tab.sections.length; i++) {
    let section = tab.sections[i]
    let wordParam = section.maker ? section.maker.call(this, words) : this.makeWordParam(words)
    if (section.url && (!section.param || section.param != wordParam)) {
      section.param = wordParam
      let url = section.url + wordParam
      section.content.src = url
      section.urldisp.innerText = url
      section.urldisp.href = url
    } else if (section.id == 'xet-charades' && section.param != wordParam) {
      section.param = wordParam
      this.updateCharades(wordParam)
    } else if (section.id == 'xet-companag' && section.param != wordParam) {
      section.param = wordParam
      this.caFodder.value = wordParam
      this.caAnagram.value = ''
      this.updateCA()
    }
  }
}

Exet.prototype.navDarkness = function(row, col) {
  darkness = this.puz.grid[row][col].darkness
  if (!darkness) {
    return
  }
  this.puz.deactivateCurrCell()
  this.puz.currRow = row
  this.puz.currCol = col

  darkness.style.fill = this.puz.colorScheme['caret']

  let cellLeft = this.puz.cellLeftPos(col, this.puz.GRIDLINE)
  let cellTop = this.puz.cellTopPos(row, this.puz.GRIDLINE)
  this.puz.gridInputWrapper.style.left = '' + cellLeft + 'px'
  this.puz.gridInputWrapper.style.top = '' + cellTop + 'px'
  this.puz.gridInput.value = ''
  this.puz.gridInputRarr.style.display = 'none'
  this.puz.gridInputDarr.style.display = 'none'
  this.puz.gridInputWrapper.style.display = ''
  this.puz.gridInput.focus()
}

Exet.prototype.arrowNav = function(key) {
  let row = this.puz.currRow
  let col = this.puz.currCol
  let useSaved = false
  if (key == 39) {
    // right arrow
    col = col + 1
    if (col >= this.puz.gridWidth) {
      useSaved = true
    }
  } else if (key == 37) {
    // left arrow
    col = col - 1
    if (col < 0) {
      useSaved = true
    }
  } else if (key == 40) {
    // down arrow
    row = row + 1
    if (row >= this.puz.gridHeight) {
      useSaved = true
    }
  } else if (key == 38) {
    // up arrow
    row = row - 1
    if (row < 0) {
      useSaved = true
    }
  }
  if (useSaved || this.puz.grid[row][col].isLight) {
    return this.hkuiSaved.apply(exet.puz, arguments);
  }
  this.navDarkness(row, col)
  return true
}

Exet.prototype.scrollCluesIfNeeded = function() {
  let clue = this.puz.clues[this.puz.currClueIndex]
  if (!clue) return
  let elt = clue.clueTR
  if (!elt) return
  const parPos = this.cluesPanel.getBoundingClientRect();
  if (parPos.bottom < 0) {
    return
  }
  let windowH = this.puz.getViewportHeight()
  if (!windowH || windowH <= 0) {
    return
  }
  if (parPos.top >= windowH) {
    return
  }
  const pos = elt.getBoundingClientRect();
  let ref = this.cluesPanel.firstElementChild
  if (pos.bottom < 0 || pos.bottom < parPos.top || pos.top >= windowH ||
      pos.top < parPos.top || pos.top >= parPos.bottom) {
    this.cluesPanel.scrollTop = pos.top - ref.getBoundingClientRect().top
  }
}

Exet.prototype.replaceHandlers = function() {
  this.puz.cnavToInner = (function() {
    exet.cnavToInnerSaved = exet.puz.cnavToInner;
    return function() {
      let ret = exet.cnavToInnerSaved.apply(exet.puz, arguments);
      exet.scrollCluesIfNeeded()
      exet.makeClueEditable()
      exet.updateFillChoices()
      exet.startDeadendSweep(exet.puz.currClueIndex)
      exet.handleTabClick(exet.currTab)
      return ret
    };
  })();
  this.puz.activateCell = (function() {
    exet.activateCellSaved = exet.puz.activateCell;
    return function() {
      let ret = exet.activateCellSaved.apply(exet.puz, arguments);
      let gridCell = exet.puz.currCell()
      if (gridCell && !gridCell.isLight && gridCell.darkness) {
        exet.navDarkness(exet.puz.currRow, exet.puz.currCol)
      }
      return ret
    };
  })();
  this.puz.deactivateCurrCell = (function() {
    exet.dccSaved = exet.puz.deactivateCurrCell;
    return function() {
      let gridCell = exet.puz.currCell()
      if (gridCell && gridCell.darkness) {
        gridCell.darkness.style.fill = 'transparent'
      }
      exet.dccSaved.apply(exet.puz);
    };
  })();
  this.puz.handleKeyUpInner = (function() {
    exet.hkuiSaved = exet.puz.handleKeyUpInner;
    return function(key, shift=false) {
      if (key >= 37 && key <= 40) {
        return exet.arrowNav(key)
      }
      return exet.hkuiSaved.apply(exet.puz, arguments);
    };
  })();
  this.puz.updateAndSaveState = (function() {
    exet.uassSaved = exet.puz.updateAndSaveState;
    return function() {
      exet.uassSaved.apply(exet.puz);
      exet.throttledGridInput(null);
    };
  })();
}

Exet.prototype.makeClueEditable = function() {
  if (!this.puz.currClueIndex || !this.puz.currClue) {
    return
  }
  let theClue = this.puz.clues[this.puz.currClueIndex]
  if (!theClue) {
    return
  }
  let currClueText = document.getElementById(
     `${exet.puz.prefix}-curr-clue-text`)
  currClueText.innerHTML = `<span class="xet-action">Edit
      clue: </span><span
      contenteditable="true" class="xet-editable"
      id="xet-clue">${theClue.clue}</span>`
  let xetClue = document.getElementById("xet-clue")
  let handler = this.throttledClueChange.bind(this)
  xetClue.addEventListener('input', handler)

  let spacer = document.createElement('span')
  spacer.innerHTML = `<br><span class="xet-action">Edit
      optional anno: </span>`
  this.puz.currClue.appendChild(spacer)

  let inCurrAnno = document.createElement('span')
  inCurrAnno.className = 'xet-anno xet-editable'
  inCurrAnno.id = 'xet-anno'
  inCurrAnno.contentEditable = true
  inCurrAnno.innerText = theClue.anno
  this.puz.currClue.appendChild(inCurrAnno)
  inCurrAnno.addEventListener('input', handler)
  this.puz.makeCurrClueVisible()
}

Exet.prototype.throttledClueChange = function() {
  if (this.throttledClueTimer) {
    clearTimeout(this.throttledClueTimer);
  }
  this.throttledClueTimer = setTimeout(() => {
    this.handleClueChange()
    this.throttledClueTimer = null;
  }, this.inputLagMS);
}

Exet.prototype.handleClueChange = function() {
  if (!this.puz.currClueIndex) {
    return
  }
  let currClueText = document.getElementById('xet-clue')
  if (!currClueText) {
    return
  }
  let theClue = this.puz.clues[this.puz.currClueIndex]
  if (!theClue) {
    return
  }
  let clueTR = theClue.clueTR
  if (!clueTR) {
    return
  }
  let clueSpan = clueTR.lastElementChild.firstElementChild
  if (!clueSpan) {
    return
  }

  let currClueAnno = document.getElementById('xet-anno')
  if (!currClueAnno) {
    return
  }
  if (!theClue.annoSpan) {
    return
  }
  let expEnumLen = 0
  if (!theClue.parentClueIndex) {
    let linked = this.puz.getLinkedClues(this.puz.currClueIndex)
    for (let lci of linked) {
      expEnumLen = expEnumLen + this.puz.clues[lci].cells.length
    }
  }
  this.stripInputLF(currClueText)
  let clue = currClueText.innerText
  let clueSansEnum = clue
  let newEnum = ''
  let enumPos = clue.lastIndexOf('(')
  if (enumPos >= 0) {
    newEnum = clue.substr(enumPos).trim()
    clueSansEnum = clue.substr(0, enumPos).trim()
  }
  if (this.puz.parseEnum(newEnum).enumLen != expEnumLen) {
    if (expEnumLen > 0) {
      newEnum = '(' + expEnumLen + ')'
      clue = clueSansEnum + ' ' + newEnum
    } else {
      newEnum = ''
      clue = clueSansEnum
    }
    currClueText.innerText = clue
  }

  let oldEnum = ''
  enumPos = theClue.clue.lastIndexOf('(')
  if (enumPos >= 0) {
    oldEnum = theClue.clue.substr(enumPos).trim()
  }
  theClue.clue = clue
  clueSpan.innerText = clue

  this.stripInputLF(currClueAnno)
  theClue.anno = currClueAnno.innerText
  theClue.annoSpan.lastElementChild.innerText = currClueAnno.innerText
  this.puz.makeCurrClueVisible()
  if (oldEnum != newEnum) {
    if (this.handleGridInput()) {
      // throttledSaveRev() got callsed already
      return
    }
  }
  exetRevManager.throttledSaveRev(exetRevManager.REV_CLUE_CHANGE)
}

Exet.prototype.gridAcrossSpans = function(grid, w, row) {
  let spans = []
  let start = -1
  let len = 0
  for (let j = 0; j < w; j++) {
    if (grid[row][j].isLight) {
      if (start >= 0 && j > 0 && grid[row][j-1].isLight && !grid[row][j-1].hasBarAfter) {
        len++
      } else {
        if (len > 1) {
          spans.push([start, len])
        }
        start = j
        len = 1
      }
    } else {
      if (len > 1) {
        spans.push([start, len])
      }
      start = -1
      len = 0
    }
  }
  if (len > 1) {
    spans.push([start, len])
  }
  return spans;
}

Exet.prototype.gridDownSpans = function(grid, h, col) {
  let spans = []
  let start = -1
  let len = 0
  for (let i = 0; i < h; i++) {
    if (grid[i][col].isLight) {
      if (start >= 0 && i > 0 && grid[i-1][col].isLight && !grid[i-1][col].hasBarUnder) {
        len++
      } else {
        if (len > 1) {
          spans.push([start, len])
        }
        start = i
        len = 1
      }
    } else {
      if (len > 1) {
        spans.push([start, len])
      }
      start = -1
      len = 0
    }
  }
  if (len > 1) {
    spans.push([start, len])
  }
  return spans;
}

Exet.prototype.gridSymmetric = function(grid, w, h) {
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      let symi = h - 1 - i
      let symj = w - 1 - j
      if (grid[i][j].isLight != grid[symi][symj].isLight) {
        return false
      }
      if (!grid[i][j].isLight) continue
      if (symj > 0 && grid[i][j].hasBarAfter != grid[symi][symj - 1].hasBarAfter) {
        return false
      }
      if (symi > 0 && grid[i][j].hasBarUnder != grid[symi - 1][symj].hasBarUnder) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridHasBlocks = function(grid, w, h) {
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
    }
  }
}

Exet.prototype.gridHasBars = function(grid, w, h) {
  for (let i = 0; i < h; i++) {
    for (let j = 0; j < w; j++) {
      if (!grid[i][j].isLight) {
        continue
      }
      if (j < w - 1 && grid[i][j].hasBarAfter) {
        return true
      }
      if (i < h - 1 && grid[i][j].hasBarUnder) {
        return true
      }
    }
  }
  return false
}

Exet.prototype.gridChequeredOK = function(grid, w, h) {
  let crossers = new Array(h)
  for (let i = 0; i < h; i++) {
    crossers[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      crossers[i][j] = 0
      if (!grid[i][j].isLight) {
        continue
      }
      if ((j > 0 && grid[i][j-1].isLight && !grid[i][j-1].hasBarAfter) ||
          (j < w - 1 && grid[i][j+1].isLight && !grid[i][j].hasBarAfter)) {
        crossers[i][j]++
      }
      if ((i > 0 && grid[i-1][j].isLight && !grid[i-1][j].hasBarUnder) ||
          (i < h - 1 && grid[i+1][j].isLight && !grid[i][j].hasBarUnder)) {
        crossers[i][j]++
      }
      if (crossers[i][j] == 1 &&
          ((j > 0 && crossers[i][j-1] == 1 && !grid[i][j-1].hasBarAfter) ||
           (i > 0 && crossers[i-1][j] == 1 && !grid[i-1][j].hasBarUnder))) {
        return false
      }
    }
  }
  const minSpan = 4
  for (let i = 0; i < h; i++) {
    let spans = this.gridAcrossSpans(grid, w, i)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
      let numChecked = 0
      let numUnches = 0
      for (let j = span[0]; j < span[0] + span[1]; j++) {
        if (crossers[i][j] < 2) numUnches++
        else numChecked++
      }
      if (numUnches > numChecked + 1) {
        return false
      }
      if (numUnches == numChecked + 1 && numUnches < 5) {
        return false
      }
    }
  }
  for (let j = 0; j < w; j++) {
    let spans = this.gridDownSpans(grid, h, j)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
      let numChecked = 0
      let numUnches = 0
      for (let i = span[0]; i < span[0] + span[1]; i++) {
        if (crossers[i][j] < 2) numUnches++
        else numChecked++
      }
      if (numUnches > numChecked + 1) {
        return false
      }
      if (numUnches == numChecked + 1 && numUnches < 5) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridUnchequeredOK = function(grid, w, h) {
  let crossers = new Array(h)
  for (let i = 0; i < h; i++) {
    crossers[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      crossers[i][j] = 0
      if (!grid[i][j].isLight) {
        continue
      }
      if ((j > 0 && grid[i][j-1].isLight && !grid[i][j-1].hasBarAfter) ||
          (j < w - 1 && grid[i][j+1].isLight && !grid[i][j].hasBarAfter)) {
        crossers[i][j]++
      }
      if ((i > 0 && grid[i-1][j].isLight && !grid[i-1][j].hasBarUnder) ||
          (i < h - 1 && grid[i+1][j].isLight && !grid[i][j].hasBarUnder)) {
        crossers[i][j]++
      }
      if (crossers[i][j] < 2) {
        return false
      }
    }
  }
  const minSpan = 3
  for (let i = 0; i < h; i++) {
    let spans = this.gridAcrossSpans(grid, w, i)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
    }
  }
  for (let j = 0; j < w; j++) {
    let spans = this.gridDownSpans(grid, h, j)
    for (let span of spans) {
      if (span[1] < minSpan) {
        return false
      }
    }
  }
  return true
}

Exet.prototype.gridConnected = function(grid, w, h) {
  let cells = []
  let visited = new Array(h)
  for (let i = 0; i < h; i++) {
    visited[i] = new Array(w)
    for (let j = 0; j < w; j++) {
      visited[i][j] = false
      if (grid[i][j].isLight) {
        cells.push([i,j])
      }
    }
  }
  if (cells.length == 0) return false
  let reachable = [cells[0]]
  visited[cells[0][0]][cells[0][1]] = true
  let x = 0
  while (x < reachable.length) {
    let r = reachable[x][0]
    let c = reachable[x][1]
    x++
    if (c > 0 && grid[r][c-1].isLight && !grid[r][c-1].hasBarAfter && !visited[r][c-1]) {
      visited[r][c-1] = true
      reachable.push([r,c-1])
    }
    if (c < w - 1 && grid[r][c+1].isLight && !grid[r][c].hasBarAfter && !visited[r][c+1]) {
      visited[r][c+1] = true
      reachable.push([r,c+1])
    }
    if (r > 0 && grid[r-1][c].isLight && !grid[r-1][c].hasBarUnder && !visited[r-1][c]) {
      visited[r-1][c] = true
      reachable.push([r-1,c])
    }
    if (r < h - 1 && grid[r+1][c].isLight && !grid[r][c].hasBarUnder && !visited[r+1][c]) {
      visited[r+1][c] = true
      reachable.push([r+1,c])
    }
  }
  return reachable.length == cells.length
}

Exet.prototype.automagicBlocksInner = function(chequered) {
  const minSpan = chequered ? 4 : 3
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let wby2 = Math.ceil(w / 2)
  let h = this.puz.gridHeight
  let hby2 = Math.ceil(h / 2)
  let numCandidates = 0
  let numChanges = 0
  for (let i = 0; i < hby2; i++) {
    let symi = h - 1 - i
    let spans = this.gridAcrossSpans(grid, w, i)
    let candidates = []
    for (let span of spans) {
      for (let x = minSpan; x < span[1] - minSpan; x++) {
        let j = span[0] + x
        let symj = w - 1 - j
        if (grid[i][j].solution != '?' || grid[symi][symj].solution != '?') {
          continue
        }
        grid[i][j].isLight = false
        grid[symi][symj].isLight = false
        if (this.gridConnected(grid, w, h) &&
            ((chequered && this.gridChequeredOK(grid, w, h)) ||
             (!chequered && this.gridUnchequeredOK(grid, w, h)))) {
          candidates.push(j)
        }
        grid[i][j].isLight = true
        grid[symi][symj].isLight = true
      }
    }
    if (candidates.length == 0) {
      continue
    }
    numCandidates += candidates.length
    let randIndex = Math.floor(Math.random() * (candidates.length + 1))
    if (randIndex >= candidates.length) {
      // We randomly chose not to make a change
      continue
    }
    let j = candidates[randIndex]
    let symj = w - 1 - j
    grid[i][j].isLight = false
    grid[symi][symj].isLight = false
    numChanges += 2
  }
  for (let j = 0; j < wby2; j++) {
    let symj = w - 1 - j
    let spans = this.gridDownSpans(grid, h, j)
    let candidates = []
    for (let span of spans) {
      for (let x = minSpan; x < span[1] - minSpan; x++) {
        let i = span[0] + x
        let symi = h - 1 - i
        if (grid[i][j].solution != '?' || grid[symi][symj].solution != '?') {
          continue
        }
        grid[i][j].isLight = false
        grid[symi][symj].isLight = false
        if (this.gridConnected(grid, w, h) &&
            ((chequered && this.gridChequeredOK(grid, w, h)) ||
             (!chequered && this.gridUnchequeredOK(grid, w, h)))) {
          candidates.push(i)
        }
        grid[i][j].isLight = true
        grid[symi][symj].isLight = true
      }
    }
    if (candidates.length == 0) {
      continue
    }
    numCandidates += candidates.length
    let randIndex = Math.floor(Math.random() * (candidates.length + 1))
    if (randIndex >= candidates.length) {
      // We randomly chose not to make a change
      continue
    }
    let i = candidates[randIndex]
    let symi = h - 1 - i
    grid[i][j].isLight = false
    grid[symi][symj].isLight = false
    numChanges += 2
  }
  if (numChanges > 0) {
    this.killInvalidatedClues()
  } else {
    if (numCandidates == 0) {
      alert('Add automagic blocks: found no further candidate cells for turning into blocks')
    } else {
      alert('Add automagic blocks: found some candidate cells for turning into blocks, but random numbers favoured no changes')
    }
  }
  return numChanges > 0;
}

Exet.prototype.automagicBlocks = function() {
  let grid = this.puz.grid
  let w = this.puz.gridWidth
  let h = this.puz.gridHeight
  if (this.gridHasBars(grid, w, h)) {
    alert('Cannot add automagic blocks when the grid has barred cells');
    return false
  }
  if (!this.gridConnected(grid, w, h)) {
    alert('Cannot add automagic blocks when the grid cells are not fully connected');
    return false
  }
  if (!this.gridSymmetric(grid, w, h)) {
    alert('Cannot add automagic blocks when the grid is not fully symmetric');
    return false
  }
  if (this.gridUnchequeredOK(grid, w, h)) {
    return this.automagicBlocksInner(false)
  } else  if (this.gridChequeredOK(grid, w, h)) {
    return this.automagicBlocksInner(true)
  } else {
    alert('Cannot add automagic blocks to the current grid');
    return false
  }
  return false
}

// Can be called with e as an event or as a key directly
Exet.prototype.handleKeyDown = function(e) {
  let key = e.key || e
  if (key == '=') {
    if (this.acceptAll()) {
      this.handleGridInput()
    }
    return
  }
  let gridCell = this.puz.currCell()
  if (!gridCell) {
    return
  }
  let revType = exetRevManager.REV_GRID_CHANGE
  let row = this.puz.currRow
  let col = this.puz.currCol
  if (key == '.') {
    gridCell.isLight = !gridCell.isLight
    let symRow = this.puz.gridHeight - 1 - row
    let symCol = this.puz.gridWidth - 1 - col
    let symCell = this.puz.grid[symRow][symCol]
    symCell.isLight = gridCell.isLight
    this.killInvalidatedClues()
  } else if (key == '|') {
    if (col >= this.gridWidth - 1) {
      return
    }
    gridCell.hasBarAfter = !gridCell.hasBarAfter
    let symRow = this.puz.gridHeight - 1 - row
    let symCol = this.puz.gridWidth - 2 - col
    let symCell = this.puz.grid[symRow][symCol]
    symCell.hasBarAfter = gridCell.hasBarAfter
    this.killInvalidatedClues()
  } else if (key == '_') {
    if (row >= this.gridHeight - 1) {
      return
    }
    gridCell.hasBarUnder = !gridCell.hasBarUnder
    let symRow = this.puz.gridHeight - 2 - row
    let symCol = this.puz.gridWidth - 1 - col
    let symCell = this.puz.grid[symRow][symCol]
    symCell.hasBarUnder = gridCell.hasBarUnder
    this.killInvalidatedClues()
  } else if (key == '#') {
    if (!this.automagicBlocks()) {
      return
    }
  } else if (key == '!') {
    gridCell.prefill = !gridCell.prefill
    revType = exetRevManager.REV_METADATA_CHANGE
  } else if (key == '@') {
    gridCell.hasCircle = !gridCell.hasCircle
    revType = exetRevManager.REV_METADATA_CHANGE
  } else {
    return
  }
  this.updatePuzzle(revType)
}

Exet.prototype.throttledGridInput = function(e) {
  if (this.throttledGridTimer) {
    clearTimeout(this.throttledGridTimer);
  }
  this.throttledGridTimer = setTimeout(() => {
    this.handleGridInput()
    this.throttledGridTimer = null;
  }, this.inputLagMS);
}

// Thie will be called after Exolve's handleGridInput has done its thing.
Exet.prototype.handleGridInput = function() {
  let needsUpdate = false
  for (let row = 0; row < this.puz.gridHeight; row++) {
    for (let col = 0; col < this.puz.gridWidth; col++) {
      let gridCell = this.puz.grid[row][col]
        if (!gridCell.isLight) {
          continue
        }
        let newSol = (gridCell.currLetter != '0' ?  gridCell.currLetter : '?')
        if (gridCell.solution != newSol) {
          gridCell.solution = newSol
          needsUpdate = true
        }
        if (gridCell.currLetter != '0' && gridCell.currLetter != '?' &&
            gridCell.viablot) {
          gridCell.viablot.style.fill = 'transparent'
        }
     }
  }
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    let oldPH = theClue.placeholder
    let oldSol = theClue.solution
    theClue.placeholder = ''
    theClue.solution = ''
    let enumPos = theClue.clue.lastIndexOf('(')
    if (enumPos >= 0) {
      theClue.placeholder = this.puz.parseEnum(
          theClue.clue.substr(enumPos)).placeholder
    }
    this.puz.setClueSolution(ci)
    if (theClue.placeholder != oldPH || theClue.solution != oldSol) {
      needsUpdate = true
    }
  }
  if (needsUpdate) {
    this.updatePuzzle(exetRevManager.REV_GRIDFILL_CHANGE)
  }
  return needsUpdate
}

Exet.prototype.killInvalidatedClues = function(row, col) {
  let tempId = this.puz.id + '-temp'
  let specs = this.getExolve(tempId, true)
  document.getElementById("xet-temp").innerHTML = ''
  let newPuz = new Exolve(specs, "xet-temp", null, false)
  for (let ci in this.puz.clues) {
    if (!newPuz.clues[ci] ||
        !newPuz.sameCells(newPuz.clues[ci].cells, this.puz.clues[ci].cells)) {
      delete this.puz.clues[ci]
    }
  }
  document.getElementById("xet-temp").innerHTML = ''
  delete exolvePuzzles[tempId]
}

Exet.prototype.makeExolve = function(specs) {
  document.getElementById('xet-xlv-frame').innerHTML = ''
  if (this.puz) {
    delete exolvePuzzles[this.puz.id]
  }
  try {
    let ptemp = new Exolve(specs, 'xet-xlv-frame', this.setPuzzle.bind(this), false)
  } catch (err) {
    this.puz = null
    alert('Could not create/parse Exolve puzzle. Please reload and retry. The JavaScript console might show some diagnostic messages.')
    console.log('Could not parse Exolve specs:')
    console.log(specs)
    console.log('Error thrown was:')
    console.log(err)
  }

  if (!this.puz) {
    return
  }
  this.initViability()
  this.handleTabClick(this.currTab);
  let exetState = window.localStorage.getItem(exetRevManager.SPECIAL_KEY)
  if (!exetState) {
    exetState = {}
  } else {
    exetState = JSON.parse(exetState)
  }
  exetState.lastId = this.puz.id
  exetRevManager.saveLocal(exetRevManager.SPECIAL_KEY, JSON.stringify(exetState))
}

Exet.prototype.updatePuzzle = function(revType=0) {
  let row = this.puz.currRow
  let col = this.puz.currCol
  let dir = this.puz.currDir
  let scratch = this.puz.scratchPad.value
  this.savedIndsSelect = this.indsSelect ? this.indsSelect.value : ''

  let exolve = this.getExolve()
  this.makeExolve(exolve)

  this.puz.currDir = dir
  this.puz.currRow = row
  this.puz.currCol = col
  this.puz.scratchPad.value = scratch
  if (this.puz.currCellIsValid()) {
    if (this.puz.grid[row][col].isLight) {
      this.puz.activateCell(row, col)
    } else {
      this.navDarkness(row, col)
    }
  }
  if (revType > 0) {
    exetRevManager.throttledSaveRev(revType)
  }
}

Exet.prototype.getGrid = function(solved=true) {
  if (!this.puz) {
    return ''
  }
  let grid = ''
  for (let i = 0; i < this.puz.gridHeight; i++) {
    let gridRow = '    '
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight) {
        gridRow = gridRow + '.   '
      } else {
        gridRow = gridRow + (gridCell.currLetter != '0' ?
                             (solved ? gridCell.currLetter : '0') : '?')
        gridRow  = gridRow + (gridCell.hasCircle ? '@' : ' ')
        gridRow  = gridRow + (gridCell.prefill ? '!' : ' ')
        gridRow  = gridRow + (gridCell.hasBarAfter && gridCell.hasBarUnder ?
                              '+' : (gridCell.hasBarAfter ?
                              '|' : (gridCell.hasBarUnder ? '_' : ' ')))
      }
    }
    grid = grid + '\n' + gridRow
  }
  return grid
}

Exet.prototype.getClues = function(dir, solved=true) {
  if (!this.puz) {
    return ''
  }
  let clues = ''
  for (let ci in this.puz.clues) {
    let clue = this.puz.clues[ci]
    if (clue.dir != dir) {
      continue
    }
    clues = clues + '\n  ' + (clue.displayLabel || clue.label) + ' ' + clue.clue
    if (solved && clue.solution) {
      clues = clues + ' [' + clue.solution + ']'
    }
    if (solved && clue.anno) {
      clues = clues + ' ' + clue.anno
    }
  }
  return clues
}

Exet.prototype.getExolve = function(id='', skipClues=false, solved=true) {
  return `  ${this.otherSections}
  exolve-id: ${(id ? id : this.puz.id)}` +
  (this.puz.title ? `
  exolve-title: ${this.puz.title}` : '') +
  (this.puz.setter ? `
  exolve-setter: ${this.puz.setter}` : '') +
  (this.puz.copyright ? `
  exolve-copyright: ${this.puz.copyright}` : '') + `
  exolve-grid: ${this.getGrid(solved)}` +
  (!skipClues ? `
  exolve-across: ${this.getClues('A', solved)}
  exolve-down: ${this.getClues('D', solved)}` : '') + `
  exolve-end
  `
}

Exet.prototype.getHTML = function(solved=true) {
  return this.prefix + '\n' + this.getExolve('', false, solved) + '\n' + this.suffix
}

Exet.prototype.makeLexKey = function(partialSol) {
  let key = ''
  if (!partialSol) return key;
  let lowerSol = partialSol.toLowerCase()
  for (let i = 0; i < partialSol.length; ++i) {
    let c = lowerSol.charAt(i);
    if ((c >= 'a' && c <= 'z') || c == '?') {
      key = key + c;
    }
  }
  return key;
}

Exet.prototype.generalizeKey = function(key) {
  for (let i = key.length - 1; i >= 0; --i) {
    if (key.charAt(i) != '?') {
      return key.substr(0, i) + '?' + key.substr(i + 1);
    }
  }
  return key;
}

Exet.prototype.keyMatchesPhrase = function(key, phrase) {
  let phraseKey = this.makeLexKey(phrase)
  if (phraseKey.length != key.length) {
    return false;
  }
  for (let i = 0; i < key.length; i++) {
    if (key.charAt(i) != '?' &&
        key.charAt(i) != phraseKey.charAt(i)) {
      return false;
    }
  }
  return true
}

Exet.prototype.getLexChoices = function(partialSol) {
  let choices = []
  let key = this.makeLexKey(partialSol);
  if (!key) return choices
  let gkey = key;
  while (!exetLexicon.index[gkey]) {
    let ngkey = this.generalizeKey(gkey)
    if (ngkey == gkey) return choices
    gkey = ngkey;
  }
  let indices = exetLexicon.index[gkey];
  for (let idx of indices) {
    let phrase = exetLexicon.lexicon[idx]
    if (this.keyMatchesPhrase(key, phrase)) {
      choices.push(idx)
    }
  }
  return choices;
}

Exet.prototype.makeAnagramKey = function(phrase) {
  return phrase.toLowerCase().replace(/ /g, '').split('').sort().join('')
}

Exet.prototype.javaHash = function(key) {
  let hash = 0;
  for (let i = 0; i < key.length; i++) {
    let c = key.charCodeAt(i);
    hash = ((hash << 5) - hash) + c;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}

Exet.prototype.getAnagrams = function(phrase) {
  const key = this.makeAnagramKey(phrase);
  const NUM_SHARDS = exetLexicon.anagrams.length
  let shard = this.javaHash(key) % NUM_SHARDS
  if (shard < 0) shard += NUM_SHARDS
  let anagrams = []
  for (let idx of exetLexicon.anagrams[shard]) {
    let candidate = exetLexicon.lexicon[idx]
    if (this.makeAnagramKey(candidate) == key) {
      anagrams.push(candidate)
    }
  }
  return anagrams
}

Exet.prototype.cellsOfClue = function(theClue) {
  if (theClue.parentClueIndex) {
    return []
  } else if (!theClue.childrenClueIndices || theClue.childrenClueIndices.length == 0) {
    return theClue.cells
  }
  let cells = []
  let linked = this.puz.getLinkedClues(theClue.index)
  for (let lci of linked) {
    cells = cells.concat(this.puz.clues[lci].cells)
  }
  return cells
}

Exet.prototype.IntersectChoices = function(set1, set2) {
  let result = {}
  for (let x in set2) {
    if (set1[x]) result[x] = true
  }
  return result
}

Exet.prototype.Set2Trims = function(set1, set2) {
  for (let x in set1) {
    if (!set2[x]) return true
  }
  return false
}

Exet.prototype.findDeadendsByCell = function() {
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    let cells = this.cellsOfClue(theClue)
    let cellChoiceSets = []
    for (let cell of cells) {
      cellChoiceSets.push({})
    }
    let limit = Math.min(this.shownLightChoices, theClue.lightChoices.length)
    for (let i = 0; i < limit; i++) {
      let lchoice = theClue.lightChoices[i]
      let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
      console.assert(key.length = cells.length, key.length, cells.length)
      for (let i = 0; i < key.length; i++) {
        let letter = key.charAt(i).toUpperCase()
        cellChoiceSets[i][letter] = true
      }
    }
    for (let i = 0; i < cells.length; i++) {
      let cell = cells[i]
      let gridCell = this.puz.grid[cell[0]][cell[1]]
      if (gridCell.solution != '?') {
        continue
      }
      gridCell.choices = this.IntersectChoices(gridCell.choices, cellChoiceSets[i])
    }
  }
  let changes = 0;
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    let cells = this.cellsOfClue(theClue)
    let choices = theClue.lightChoices.slice(0, this.sweepMaxChoices)
    let remChoices = theClue.lightChoices.slice(this.sweepMaxChoices)
    theClue.lightChoices = []
    for (let lchoice of choices) {
      let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
      let viable = true
      for (let i = 0; i < key.length; i++) {
        let cell = cells[i]
        let gridCell = this.puz.grid[cell[0]][cell[1]]
        let letter = key.charAt(i).toUpperCase()
        if (gridCell.solution == '?' && !gridCell.choices[letter]) {
          viable = false
          break
        }
      }
      if (viable) {
        theClue.lightChoices.push(lchoice)
      } else {
        changes++;
      }
    }
    if (remChoices.length > 0) {
      theClue.lightChoices = theClue.lightChoices.concat(remChoices)
    }
  }
  let forceEndSweep = false
  for (let i = 0; i < this.puz.gridHeight; i++) {
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      let choices = Object.keys(gridCell.choices)
      gridCell.viability = this.viability(choices.length)
      let viablot = gridCell.viablot
      viablot.style.fill = (gridCell.viability >= 5 ?
        'transparent' : (gridCell.viability == 0 ? 'magenta' : 'red'))
      viablot.setAttributeNS(null, 'r',
                             this.puz.circleR * 0.1 * (5 - gridCell.viability));
      if (choices.length == 1) {
        if (!gridCell.forcedLetter) {
          let cellText =
            document.createElementNS('http://www.w3.org/2000/svg', 'text');
          cellText.setAttributeNS(
            null, 'x', this.puz.cellLeftPos(j, this.puz.lightStartX));
          cellText.setAttributeNS(
            null, 'y', this.puz.cellTopPos(i, this.puz.lightStartY));
          cellText.setAttributeNS(null, 'text-anchor', 'middle');
          cellText.setAttributeNS(null, 'editable', 'simple');
          let cellClass = 'xlv-cell-text'
          cellText.style.fill = 'gray'
          cellText.style.fontSize = this.puz.letterSize + 'px'
          cellText.setAttributeNS(null, 'class', cellClass)
          cellText.addEventListener('click', this.puz.cellActivator.bind(this.puz, i, j));

          const text = document.createTextNode(choices[0]);
          cellText.appendChild(text);
          this.puz.svg.appendChild(cellText)
          gridCell.forcedLetter = text
        }
        gridCell.forcedLetter.nodeValue = choices[0]
        viablot.style.fill = 'transparent'
      } else {
        if (gridCell.forcedLetter) {
          gridCell.forcedLetter.nodeValue = ''
        }
      }
      if (gridCell.viability == 0) {
        forceEndSweep = true
      }
    }
  }
  if (forceEndSweep) {
    if (this.viabilityUpdateTimer) {
      clearTimeout(this.viabilityUpdateTimer);
    }
    this.viabilityUpdateTimer = null;
    this.sweepIndicator.className = 'xet-sweeping'
    return 0;
  }
  return changes
}

Exet.prototype.acceptAll = function() {
  let changed = false;
  // First do it by clue, to get hyphens/word-breaks.
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      continue
    }
    let choices = theClue.lightChoices
    if (choices.length != 1) {
      continue
    }
    this.fillLight(choices[0], ci)
    changed = true
  }
  for (let i = 0; i < this.puz.gridHeight; i++) {
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight || gridCell.solution != '?') {
        continue
      }
      if (gridCell.forcedLetter && gridCell.forcedLetter.nodeValue) {
        let c = gridCell.forcedLetter.nodeValue
        gridCell.currLetter = c
        changed = true
      }
    }
  }
  return changed
}

// Finds a clue that becomes non-viable when it previously was viable.
// Return true if such a clue can be found.
Exet.prototype.someClueTurnsNonViable = function(tempGrid) {
  let changes = 1
  let tempClues = {}
  for (let ci in this.puz.clues) {
    tempClues[ci] = {}
    let theClue = this.puz.clues[ci]
    if (theClue.lightChoices) {
      tempClues[ci].choices = theClue.lightChoices.slice()
    }
  }
  let count = 0
  while (changes > 0 && count < 1) {
    count++
    changes = 0
    for (let ci in this.puz.clues) {
      let theClue = this.puz.clues[ci]
      if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
        continue
      }
      let cells = this.cellsOfClue(theClue)
      let cellChoiceSets = []
      for (let cell of cells) {
        cellChoiceSets.push({})
      }
      let tempClue = tempClues[ci]
      let limit = Math.min(this.shownLightChoices, tempClue.choices.length)
      for (let i = 0; i < limit; i++) {
        let lchoice = tempClue.choices[i]
        let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
        console.assert(key.length = cells.length, key.length, cells.length)
        for (let i = 0; i < key.length; i++) {
          let letter = key.charAt(i).toUpperCase()
          cellChoiceSets[i][letter] = true
        }
      }
      for (let i = 0; i < cells.length; i++) {
        let cell = cells[i]
        let gridCell = this.puz.grid[cell[0]][cell[1]]
        if (gridCell.solution != '?') {
          continue
        }
        let tempGridCell = tempGrid[cell[0]][cell[1]]
        tempGridCell.choices = this.IntersectChoices(tempGridCell.choices, cellChoiceSets[i])
      }
    }
    for (let ci in this.puz.clues) {
      let theClue = this.puz.clues[ci]
      if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
        continue
      }
      let cells = this.cellsOfClue(theClue)
      let tempClue = tempClues[ci]
      if (tempClue.choices.length > this.sweepMaxChoicesSmall) {
        continue
      }
      let choices = tempClue.choices.slice()
      tempClue.choices = []
      for (let i = 0; i < choices.length; i++) {
        let lchoice = choices[i]
        let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
        let viable = true
        for (let i = 0; i < key.length; i++) {
          let cell = cells[i]
          let gridCell = this.puz.grid[cell[0]][cell[1]]
          if (gridCell.solution != '?') {
            continue
          }
          let tempGridCell = tempGrid[cell[0]][cell[1]]
          let letter = key.charAt(i).toUpperCase()
          if (!tempGridCell.choices[letter]) {
            viable = false
            break
          }
        }
        if (viable) {
          tempClue.choices.push(lchoice)
        } else {
          changes++;
        }
      }
      if (choices.length > 0 && tempClue.choices.length == 0) {
        return true
      }
    }
  }
  return false
}

// Returns true if should be called again
Exet.prototype.findDeadendsByClue = function() {
  let ci = this.deadendClueCheck
  if (!ci) {
    return false
  }
  let theClue = this.puz.clues[ci]
  if (!theClue) {
    return false
  }
  if (theClue.parentClueIndex) {
    ci = theClue.parentClueIndex
    theClue = this.puz.clues[ci]
  }
  if (!theClue.solution || theClue.solution.indexOf('?')) {
    return false
  }
  let cells = this.cellsOfClue(theClue)
  if (this.deadendClueLightCheck >= theClue.lightChoices.length ||
      cells.length == 0) {
    return false
  }
  if (this.deadendClueLightCheck >= this.shownLightChoices) {
    return false
  }
  const CHOICES_TO_CHECK = 3
  let prefix = theClue.lightChoices.slice(0, this.deadendClueLightCheck)
  let choices = theClue.lightChoices.slice(this.deadendClueLightCheck, this.deadendClueLightCheck + CHOICES_TO_CHECK)
  let viableChoices = []
  let suffix = theClue.lightChoices.slice(this.deadendClueLightCheck + CHOICES_TO_CHECK)
  let oldLen = theClue.lightChoices.length
  for (let lchoice of choices) {
    let key = this.makeLexKey(exetLexicon.lexicon[lchoice])
    console.assert(key.length = cells.length, key.length, cells.length)
    let tempGrid = new Array(this.puz.gridHeight)
    for (let r = 0; r < this.puz.gridHeight; r++) {
      tempGrid[r] = new Array(this.puz.gridWidth)
      for (let c = 0; c < this.puz.gridWidth; c++) {
        tempGrid[r][c] = {}
        if (this.puz.grid[r][c].choices) {
          tempGrid[r][c].choices = this.puz.grid[r][c].choices
        }
      }
    }
    for (let i = 0; i < cells.length; i++) {
      let cell = cells[i]
      let tempGridCell = tempGrid[cell[0]][cell[1]]
      tempGridCell.choices = {}
      let letter = key.charAt(i).toUpperCase()
      tempGridCell.choices[letter] = true
    }
    if (!this.someClueTurnsNonViable(tempGrid)) {
      viableChoices.push(lchoice)
    }
  }
  theClue.lightChoices = prefix.concat(viableChoices, suffix)
  this.deadendClueCheckChanges += (oldLen - theClue.lightChoices.length)
  this.deadendClueLightCheck +=  viableChoices.length
  return this.deadendClueLightCheck < theClue.lightChoices.length
}

Exet.prototype.startDeadendSweep = function(ci='') {
  if (this.viabilityUpdateTimer) {
    clearTimeout(this.viabilityUpdateTimer);
  }
  this.viabilityUpdateTimer = null;
  if (!this.puz || this.puz.numCellsFilled >= this.puz.numCellsToFill) {
    return
  }
  this.deadendsGridSweep = true
  this.viabilityUpdateTimer = setTimeout(() => {
    this.findAllDeadendFills(ci)
  }, this.sweepMS);
}

Exet.prototype.getClueToCheckDeadends = function(ci) {
  if (ci) {
    let theClue = this.puz.clues[ci]
    if (theClue.parentClueIndex) {
      ci = theClue.parentClueIndex
      theClue = this.puz.clues[ci]
    }
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) {
      return ''
    }
    return ci
  }
  // Find most constrained unsolved and still-viable clue
  let res = ''
  let resChoices = exetLexicon.lexicon.length
  for (ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    if (theClue.parentClueIndex) continue
    if (!theClue.solution || theClue.solution.indexOf('?') < 0) continue
    if (theClue.lightChoices.length > 0 && theClue.lightChoices.length < resChoices) {
      resChoices = theClue.lightChoices.length
      res = ci
    }
  }
  return res
}

Exet.prototype.findAllDeadendFills = function(ci) {
  if (this.viabilityUpdateTimer) {
    clearTimeout(this.viabilityUpdateTimer);
  }
  this.viabilityUpdateTimer = null;
  this.sweepIndicator.className = 'xet-sweeping-animated'
  if (this.deadendsGridSweep) {
    let changes = this.findDeadendsByCell()
    if (changes > 0) {
      this.updateFillChoices()
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills(ci)
      }, this.sweepMS);
    } else {
      // Start the clue-sweep
      this.deadendsGridSweep = false
      this.deadendClueLightCheck = 0;
      this.deadendClueCheckChanges = 0;
      this.deadendClueCheck = this.getClueToCheckDeadends(ci);
      if (!this.deadendClueCheck) {
        this.sweepIndicator.className = 'xet-sweeping'
        return
      }
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills()
      }, this.sweepMS);
    }
  } else {
    let doMore = this.findDeadendsByClue()
    if (this.deadendClueCheckChanges > 0) {
      this.updateFillChoices()
    }
    if (!doMore) {
      this.deadendsGridSweep = true
      if (this.deadendClueCheckChanges > 0) {
        // Repeat the grid-sweep
        this.viabilityUpdateTimer = setTimeout(() => {
          this.findAllDeadendFills()
        }, this.sweepMS);
      } else {
        this.sweepIndicator.className = 'xet-sweeping'
      }
    } else {
      this.viabilityUpdateTimer = setTimeout(() => {
        this.findAllDeadendFills()
      }, this.sweepMS);
    }
  }
}

Exet.prototype.viability = function(len) {
  const log2 = 0.6931471805599453;
  return len == 0 ? 0 : (len >= 16 ? 5 : (1 + (Math.log(len) / log2)));
}

Exet.prototype.initViability = function() {
  for (let i = 0; i < this.puz.gridHeight; i++) {
    for (let j = 0; j < this.puz.gridWidth; j++) {
      let gridCell = this.puz.grid[i][j]
      if (!gridCell.isLight) {
        continue
      }
      if (gridCell.solution != '?') {
        gridCell.choices = {}
        gridCell.choices[gridCell.solution] = true
        gridCell.viability = 1.0;
      } else {
        gridCell.choices = this.allLetters
        gridCell.viability = 5.0;
      }
    }
  }
}

Exet.prototype.updateViability = function() {
  for (let ci in this.puz.clues) {
    let theClue = this.puz.clues[ci]
    let key = this.makeLexKey(theClue.solution)
    theClue.lightChoices = this.getLexChoices(key)
  }
  this.updateFillChoices()
  this.startDeadendSweep()
}

Exet.prototype.fillLight = function(idx, ci='') {
  let updateIfChanged = false
  if (!ci && this.puz) {
    ci = this.puz.currClueIndex
    updateIfChanged = true
  }
  if (!ci) {
    return
  }
  let solution = exetLexicon.lexicon[idx]
  let theClue = this.puz.clues[ci]
  if (!theClue || !solution ||
      this.makeLexKey(solution).length != theClue.cells.length) {
    return
  }
  solution = solution.toUpperCase()
  let changed = false;
  if (theClue.solution != solution) {
    theClue.solution = solution
    changed = true
  }
  let enumStr = ''
  let enumPart = 0
  let solIndex = 0
  for (let i = 0; i < solution.length; i++) {
    let c = solution.charAt(i);
    if (enumPart > 0 && (c == ' ' || c == '-' || c == '\'')) {
      enumStr = enumStr + enumPart + (c == ' ' ? ',' : c)
      enumPart = 0
    }
    if (c >= 'A' && c <= 'Z') {
      enumPart++
      let cell = theClue.cells[solIndex++]
      let gridCell = this.puz.grid[cell[0]][cell[1]]
      if (gridCell.currLetter != c || gridCell.solution != c) {
        gridCell.currLetter = c
        changed = true
      }
    }
  }
  if (enumPart > 0) {
    enumStr = enumStr + enumPart
  }
  let clueEnumStart = theClue.clue.lastIndexOf('(')
  let clueEnumEnd = theClue.clue.lastIndexOf(')')
  if (clueEnumStart > 0 && clueEnumEnd > clueEnumStart + 1) {
    let clueEnum = theClue.clue.substring(clueEnumStart + 1, clueEnumEnd)
    if (clueEnum != enumStr) {
      theClue.clue = theClue.clue.substr(0, clueEnumStart).trim() +
        ' (' + enumStr + ')'
      changed = true
    }
  } else {
    theClue.clue = theClue.clue.trim() + ' (' + enumStr + ')'
    changed = true
  }
  if (changed && updateIfChanged) {
    this.handleGridInput()
  }
}

Exet.prototype.updateFillChoices = function() {
  if (!this.puz.currClueIndex) {
    return
  }
  let theClue = this.puz.clues[this.puz.currClueIndex]
  if (!theClue || !theClue.lightChoices) {
    return
  }
  let html = ''
  let numShown = 0
  for (let choice of theClue.lightChoices) {
    html = html + `
      <tr><td>${exetLexicon.lexicon[choice]}</td></tr>
    `
    numShown++
    if (numShown >= this.shownLightChoices) break;
  }
  let htmlHash = this.javaHash(html + this.puz.currClueIndex)
  if (this.shownChoicesHash && this.shownChoicesHash == htmlHash) {
    return
  }
  this.shownChoicesHash = htmlHash
  this.lightChoices.innerHTML = html
  let trs = this.lightChoices.getElementsByTagName('tr')
  for (let i = 0; i < trs.length; i++) {
    trs[i].addEventListener('click', this.fillLight.bind(this, theClue.lightChoices[i], ''))
  }
}

function exetFromHistory(exetRev) {
  exet.prefix = exetRev.prefix
  exet.suffix = exetRev.suffix
  exet.makeExolve(exetRev.exolve)
  if (exetRev.navState) {
    exet.startNav(exetRev.navState[0], exetRev.navState[1], exetRev.navState[2])
  } else {
    exet.startNav()
  }
  if (exetRev.scratchPad && exet.puz && exet.puz.scratchPad) {
    exet.puz.scratchPad.value = exetRev.scratchPad
  }
  if (exet.puz && exet.puz.id && exetRev.revNum < exetRev.maxRevNum) {
    exetRevManager.throttledSaveRev(exetRevManager.REV_JUMPED_TO_REV,
                                    '' + exetRev.revNum);
  }
}

function exetBlank(w=15, h=15, id='', automagic=false, checkered=true,
                   topUnches=false, leftUnches=false) {
  if (!w || !h || w <= 0 || h <= 0 || w > 100 || h > 100) {
    alert('Width and height must be specified in the range, 1-100')
    return
  }
  if (!id) {
    id = `puz-${Math.random().toString(36).substring(2, 8)}`
  }

  let gridRow = ['', '']
  for (let j = 0; j < w; j++) {
    if (checkered) {
      if (!topUnches && !leftUnches) {
        gridRow[0] = gridRow[0] + '?'
        gridRow[1] = gridRow[1] + (j % 2 == 0 ? '?' : '.')
      } else if (!topUnches && leftUnches) {
        gridRow[0] = gridRow[0] + '?'
        gridRow[1] = gridRow[1] + (j % 2 == 0 ? '.' : '?')
      } else if (topUnches && !leftUnches) {
        gridRow[0] = gridRow[0] + (j % 2 == 0 ? '?' : '.')
        gridRow[1] = gridRow[1] + '?'
      } else if (topUnches && leftUnches) {
        gridRow[0] = gridRow[0] + (j % 2 == 0 ? '.' : '?')
        gridRow[1] = gridRow[1] + '?'
      }
    } else {
      gridRow[0] = gridRow[0] + '?'
      gridRow[1] = gridRow[1] + '?'
    }
  }
  let grid = ''
  for (let i = 0; i < h; i++) {
    grid = grid + '\n  ' + gridRow[i % 2]
  }

  let specs = `exolve-begin
    exolve-id: ${id}
    exolve-title: Exet Crossword
    exolve-setter: Exetter
    exolve-width: ${w}
    exolve-height: ${h}
    exolve-grid: ${grid}
    exolve-across:
    exolve-down:
  exolve-end
  `
  exet.makeExolve(specs)
  exet.startNav()
  if (!exet.puz || !exet.puz.id) {
    alert('Failed to create/load crossword, unfortunately. Perhaps the JavaScript console may have logged some error messages.')
    return
  }

  if (automagic && exet.automagicBlocks()) {
    exet.updatePuzzle(exetRevManager.REV_CREATED_AUTOBLOCK)
    return
  }
  exetRevManager.throttledSaveRev(exetRevManager.REV_CREATED_BLANK)
}

function exetLoadFile() {
  let fr = new FileReader(); 
  fr.onload = function(){ 
    let start = fr.result.indexOf('exolve-begin')
    let end = fr.result.indexOf('exolve-end')
    if (start < 0 || end < 0 || start >= end) {
      alert('Invalid Exolve specifications')
      return
    }
    end += 'exolve-end'.length
    exet.prefix = fr.result.substring(0, start).trim()
    exet.suffix = fr.result.substring(end).trim()
    let specs = fr.result.substring(start, end)
    exet.makeExolve(specs)
    exet.startNav()
    if (exet.puz && exet.puz.id) {
      exetRevManager.throttledSaveRev(
          exetRevManager.REV_LOADED_FROM_FILE,
          exetFileName);
    }
  } 
  let f = document.getElementById('xet-file').files[0]
  exetFileName = f.name
  fr.readAsText(f)
}

let exetFileName = ''
let exetRevManager = new ExetRevManager();
let exetModals = new ExetModals();
let exet = new Exet;
if (!window.localStorage) {
  throw "localStorage is not available!"
}
let exetState = window.localStorage.getItem(exetRevManager.SPECIAL_KEY)
if (exetState) {
  exetState = JSON.parse(exetState)
  let id = exetState.lastId
  let saved = window.localStorage.getItem(id)
  if (saved) {
    saved = JSON.parse(saved)
    if (saved.revs.length > 0) {
      exetFromHistory(saved.revs[saved.revs.length - 1])
    }
  }
}
if (!exet.puz) {
  let url = new URL(location.href)
  let newgrid = url.searchParams.get('newgrid')
  if (newgrid == 'blank') {
    exetBlank(15, 15, '', false, false)
  } else {
    exetBlank()
  }
}

</script>

</body>
</html>
